//----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace GosuNET
{
    namespace Gosu
    {
        // <summary>
        // <para>An instance of a Sample playing. Can be used to stop sounds dynamically,</para>
        // <para>or to check if they are finished.</para>
        // <para>It is recommended that you throw away sample instances if possible,</para>
        // <para>as they could accidentally refer to other sounds being played after</para>
        // <para>a very long time has passed.</para>
        // </summary>
        public unsafe partial class SampleInstance : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                public int handle;

                [FieldOffset(4)]
                public int extra;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0SampleInstance@Gosu@@QAE@HH@Z")]
                internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, int handle, int extra);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0SampleInstance@Gosu@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?pause@SampleInstance@Gosu@@QAEXXZ")]
                internal static extern void Pause_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?resume@SampleInstance@Gosu@@QAEXXZ")]
                internal static extern void Resume_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?stop@SampleInstance@Gosu@@QAEXXZ")]
                internal static extern void Stop_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?changeVolume@SampleInstance@Gosu@@QAEXN@Z")]
                internal static extern void ChangeVolume_0(global::System.IntPtr instance, double volume);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?changePan@SampleInstance@Gosu@@QAEXN@Z")]
                internal static extern void ChangePan_0(global::System.IntPtr instance, double pan);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?changeSpeed@SampleInstance@Gosu@@QAEXN@Z")]
                internal static extern void ChangeSpeed_0(global::System.IntPtr instance, double speed);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?playing@SampleInstance@Gosu@@QBE_NXZ")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool Playing_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?paused@SampleInstance@Gosu@@QBE_NXZ")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool Paused_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SampleInstance> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SampleInstance>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static SampleInstance __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new SampleInstance(native.ToPointer(), skipVTables);
            }

            public static SampleInstance __CreateInstance(SampleInstance.__Internal native, bool skipVTables = false)
            {
                return new SampleInstance(native, skipVTables);
            }

            private static void* __CopyValue(SampleInstance.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(8);
                *(SampleInstance.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private SampleInstance(SampleInstance.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SampleInstance(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            // <summary>
            // <para>Called by Sample, do not use.</para>
            // </summary>
            public SampleInstance(int handle, int extra)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor_0((__Instance + __PointerAdjustment), handle, extra);
            }

            public SampleInstance(Gosu.SampleInstance _0)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((SampleInstance.__Internal*) __Instance) = *((SampleInstance.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                Gosu.SampleInstance __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            // <summary>
            // <para>Pauses this instance to be resumed afterwards. It will still keep a channel filled while paused.</para>
            // </summary>
            public void Pause()
            {
                __Internal.Pause_0((__Instance + __PointerAdjustment));
            }

            public void Resume()
            {
                __Internal.Resume_0((__Instance + __PointerAdjustment));
            }

            // <summary>
            // <para>Stops this instance of a sound being played.</para>
            // <para>Calling this twice, or too late, does not do any harm.</para>
            // </summary>
            public void Stop()
            {
                __Internal.Stop_0((__Instance + __PointerAdjustment));
            }

            // <param name="volume">
            // <para>Can be anything from 0.0 (silence) to 1.0 (full</para>
            // <para>volume).</para>
            // </param>
            public void ChangeVolume(double volume)
            {
                __Internal.ChangeVolume_0((__Instance + __PointerAdjustment), volume);
            }

            // <param name="pan">
            // <para>Can be anything from -1.0 (left) to 1.0 (right).</para>
            // </param>
            public void ChangePan(double pan)
            {
                __Internal.ChangePan_0((__Instance + __PointerAdjustment), pan);
            }

            // <param name="speed">
            // <para>Playback speed is only limited by FMOD's</para>
            // <para>capabilities and can accept very high or low values. Use 1.0 for</para>
            // <para>normal playback speed.</para>
            // </param>
            public void ChangeSpeed(double speed)
            {
                __Internal.ChangeSpeed_0((__Instance + __PointerAdjustment), speed);
            }

            public bool Playing
            {
                get
                {
                    var __ret = __Internal.Playing_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool Paused
            {
                get
                {
                    var __ret = __Internal.Paused_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        // <summary>
        // <para>A sample is a short sound that is completely loaded in memory, can be</para>
        // <para>played multiple times at once and offers very flexible playback</para>
        // <para>parameters. Use samples for everything that's not music.</para>
        // </summary>
        public unsafe partial class Sample : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Std.SharedPtr.__Internal data;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Sample@Gosu@@QAE@PBD@Z")]
                internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string filename);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Sample@Gosu@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_5(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??1Sample@Gosu@@QAE@XZ")]
                internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?play@Sample@Gosu@@QBE?AVSampleInstance@2@NN_N@Z")]
                internal static extern void Play_0(global::System.IntPtr instance, global::System.IntPtr @return, double volume, double speed, bool looping);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?playPan@Sample@Gosu@@QBE?AVSampleInstance@2@NNN_N@Z")]
                internal static extern void PlayPan_0(global::System.IntPtr instance, global::System.IntPtr @return, double pan, double volume, double speed, bool looping);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Sample> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Sample>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static Sample __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new Sample(native.ToPointer(), skipVTables);
            }

            public static Sample __CreateInstance(Sample.__Internal native, bool skipVTables = false)
            {
                return new Sample(native, skipVTables);
            }

            private static void* __CopyValue(Sample.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(8);
                Gosu.Sample.__Internal.cctor_5(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private Sample(Sample.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Sample(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            // <summary>
            // <para>Constructs a sample that can be played on the specified audio</para>
            // <para>system and loads the sample from a file.</para>
            // </summary>
            public Sample(string filename)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = filename;
                __Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
            }

            public Sample(Gosu.Sample _0)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_5((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                Gosu.Sample __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            // <summary>
            // <para>Plays the sample without panning.</para>
            // </summary>
            // <param name="volume">
            // <para>Can be anything from 0.0 (silence) to 1.0 (full</para>
            // <para>volume).</para>
            // </param>
            // <param name="speed">
            // <para>Playback speed is only limited by the underlying audio library,</para>
            // <para>and can accept very high or low values. Use 1.0 for</para>
            // <para>normal playback speed.</para>
            // </param>
            public Gosu.SampleInstance Play(double volume = 1, double speed = 1, bool looping = false)
            {
                var __ret = new Gosu.SampleInstance.__Internal();
                __Internal.Play_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), volume, speed, looping);
                return Gosu.SampleInstance.__CreateInstance(__ret);
            }

            // <summary>
            // <para>Plays the sample with panning. Even if pan is 0.0, the sample will</para>
            // <para>not be as loud as if it were played by calling play() due to the</para>
            // <para>way the panning works.</para>
            // </summary>
            // <param name="pan">
            // <para>Can be anything from -1.0 (left) to 1.0 (right).</para>
            // </param>
            // <param name="volume">
            // <para>Can be anything from 0.0 (silence) to 1.0 (full</para>
            // <para>volume).</para>
            // </param>
            // <param name="speed">
            // <para>Playback speed is only limited by by the underlying audio library,</para>
            // <para>and can accept very high</para>
            // <para>or low values. Use 1.0 for normal playback speed.</para>
            // </param>
            public Gosu.SampleInstance PlayPan(double pan, double volume = 1, double speed = 1, bool looping = false)
            {
                var __ret = new Gosu.SampleInstance.__Internal();
                __Internal.PlayPan_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), pan, volume, speed, looping);
                return Gosu.SampleInstance.__CreateInstance(__ret);
            }

            public static explicit operator Gosu.Sample(string filename)
            {
                return new Gosu.Sample(filename);
            }
        }

        // <summary>
        // <para>Songs are less flexible than samples in that they can only be played</para>
        // <para>one at a time and without panning or speed parameters.</para>
        // </summary>
        public unsafe partial class Song : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Std.UniquePtr.__Internal data;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Song@Gosu@@QAE@PBD@Z")]
                internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string filename);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??1Song@Gosu@@QAE@XZ")]
                internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?play@Song@Gosu@@QAEX_N@Z")]
                internal static extern void Play_0(global::System.IntPtr instance, bool looping);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?pause@Song@Gosu@@QAEXXZ")]
                internal static extern void Pause_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?stop@Song@Gosu@@QAEXXZ")]
                internal static extern void Stop_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?changeVolume@Song@Gosu@@QAEXN@Z")]
                internal static extern void ChangeVolume_0(global::System.IntPtr instance, double volume);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?update@Song@Gosu@@SAXXZ")]
                internal static extern void Update_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?currentSong@Song@Gosu@@SAPAV12@XZ")]
                internal static extern global::System.IntPtr CurrentSong_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?paused@Song@Gosu@@QBE_NXZ")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool Paused_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?playing@Song@Gosu@@QBE_NXZ")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool Playing_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?volume@Song@Gosu@@QBENXZ")]
                internal static extern double Volume_0(global::System.IntPtr instance);
            }

            public enum Type
            {
                StStream = 0,
                StModule = 1
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Song> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Song>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static Song __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new Song(native.ToPointer(), skipVTables);
            }

            public static Song __CreateInstance(Song.__Internal native, bool skipVTables = false)
            {
                return new Song(native, skipVTables);
            }

            private static void* __CopyValue(Song.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(4);
                *(Song.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Song(Song.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Song(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            // <summary>
            // <para>Constructs a song that can be played on the provided audio system</para>
            // <para>and loads the song from a file. The type is determined from the</para>
            // <para>filename.</para>
            // </summary>
            public Song(string filename)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = filename;
                __Internal.ctor_2((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                Gosu.Song __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            // <summary>
            // <para>Starts or resumes playback of the song. This will stop all other</para>
            // <para>songs and set the current song to this object.</para>
            // </summary>
            public void Play(bool looping = false)
            {
                __Internal.Play_0((__Instance + __PointerAdjustment), looping);
            }

            // <summary>
            // <para>Pauses playback of the song. It is not considered being played.</para>
            // <para>currentSong will stay the same.</para>
            // </summary>
            public void Pause()
            {
                __Internal.Pause_0((__Instance + __PointerAdjustment));
            }

            // <summary>
            // <para>Stops playback of this song if it is currently played or paused.</para>
            // <para>Afterwards, currentSong will return 0.</para>
            // </summary>
            public void Stop()
            {
                __Internal.Stop_0((__Instance + __PointerAdjustment));
            }

            // <summary>
            // <para>Changes the volume of the song.</para>
            // </summary>
            public void ChangeVolume(double volume)
            {
                __Internal.ChangeVolume_0((__Instance + __PointerAdjustment), volume);
            }

            public static explicit operator Gosu.Song(string filename)
            {
                return new Gosu.Song(filename);
            }

            // <summary>
            // <para>Called every tick by Window for management purposes.</para>
            // </summary>
            public static void Update()
            {
                __Internal.Update_0();
            }

            // <summary>
            // <para>Returns the song currently being played or paused, or 0 if</para>
            // <para>no song has been played yet or the last song has finished</para>
            // <para>playing.</para>
            // </summary>
            public static Gosu.Song CurrentSong
            {
                get
                {
                    var __ret = __Internal.CurrentSong_0();
                    Gosu.Song __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (Gosu.Song.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (Gosu.Song) Gosu.Song.NativeToManagedMap[__ret];
                    else __result0 = Gosu.Song.__CreateInstance(__ret);
                    return __result0;
                }
            }

            // <summary>
            // <para>Returns true if the song is the current song, but in paused</para>
            // <para>mode.</para>
            // </summary>
            public bool Paused
            {
                get
                {
                    var __ret = __Internal.Paused_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            // <summary>
            // <para>Returns true if the song is currently playing.</para>
            // </summary>
            public bool Playing
            {
                get
                {
                    var __ret = __Internal.Playing_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            // <summary>
            // <para>Returns the current volume of the song.</para>
            // </summary>
            public double Volume
            {
                get
                {
                    var __ret = __Internal.Volume_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }
    }

    namespace Gosu
    {
        // <summary>
        // <para>Serves as the target of all drawing and provides primitive drawing</para>
        // <para>functionality.</para>
        // <para>Usually created internally by Gosu::Window.</para>
        // </summary>
        public unsafe partial class Graphics : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Std.UniquePtr.__Internal pimpl;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Graphics@Gosu@@QAE@II_N@Z")]
                internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, uint physicalWidth, uint physicalHeight, bool fullscreen);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??1Graphics@Gosu@@QAE@XZ")]
                internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setResolution@Graphics@Gosu@@QAEXIINN@Z")]
                internal static extern void SetResolution_0(global::System.IntPtr instance, uint logicalWidth, uint logicalHeight, double horizontalBlackBarWidth, double verticalBlackBarHeight);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?begin@Graphics@Gosu@@QAE_NVColor@2@@Z")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool Begin_0(global::System.IntPtr instance, Gosu.Color.__Internal clearWithColor);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?end@Graphics@Gosu@@QAEXXZ")]
                internal static extern void End_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?flush@Graphics@Gosu@@SAXXZ")]
                internal static extern void Flush_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?beginGL@Graphics@Gosu@@SAXXZ")]
                internal static extern void BeginGL_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?endGL@Graphics@Gosu@@SAXXZ")]
                internal static extern void EndGL_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?beginClipping@Graphics@Gosu@@SAXNNNN@Z")]
                internal static extern void BeginClipping_0(double x, double y, double width, double height);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?endClipping@Graphics@Gosu@@SAXXZ")]
                internal static extern void EndClipping_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?beginRecording@Graphics@Gosu@@SAXXZ")]
                internal static extern void BeginRecording_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?popTransform@Graphics@Gosu@@SAXXZ")]
                internal static extern void PopTransform_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?drawLine@Graphics@Gosu@@SAXNNVColor@2@NN0NW4AlphaMode@2@@Z")]
                internal static extern void DrawLine_0(double x1, double y1, Gosu.Color.__Internal c1, double x2, double y2, Gosu.Color.__Internal c2, double z, Gosu.AlphaMode mode);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?drawTriangle@Graphics@Gosu@@SAXNNVColor@2@NN0NN0NW4AlphaMode@2@@Z")]
                internal static extern void DrawTriangle_0(double x1, double y1, Gosu.Color.__Internal c1, double x2, double y2, Gosu.Color.__Internal c2, double x3, double y3, Gosu.Color.__Internal c3, double z, Gosu.AlphaMode mode);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?drawQuad@Graphics@Gosu@@SAXNNVColor@2@NN0NN0NN0NW4AlphaMode@2@@Z")]
                internal static extern void DrawQuad_0(double x1, double y1, Gosu.Color.__Internal c1, double x2, double y2, Gosu.Color.__Internal c2, double x3, double y3, Gosu.Color.__Internal c3, double x4, double y4, Gosu.Color.__Internal c4, double z, Gosu.AlphaMode mode);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setPhysicalResolution@Graphics@Gosu@@QAEXII@Z")]
                internal static extern void SetPhysicalResolution_0(global::System.IntPtr instance, uint physicalWidth, uint physicalHeight);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?width@Graphics@Gosu@@QBEIXZ")]
                internal static extern uint Width_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?height@Graphics@Gosu@@QBEIXZ")]
                internal static extern uint Height_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?fullscreen@Graphics@Gosu@@QBE_NXZ")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool Fullscreen_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Graphics> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Graphics>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static Graphics __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new Graphics(native.ToPointer(), skipVTables);
            }

            public static Graphics __CreateInstance(Graphics.__Internal native, bool skipVTables = false)
            {
                return new Graphics(native, skipVTables);
            }

            private static void* __CopyValue(Graphics.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(4);
                *(Graphics.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Graphics(Graphics.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Graphics(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public Graphics(uint physicalWidth, uint physicalHeight, bool fullscreen)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor_2((__Instance + __PointerAdjustment), physicalWidth, physicalHeight, fullscreen);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                Gosu.Graphics __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public void SetResolution(uint logicalWidth, uint logicalHeight, double horizontalBlackBarWidth = 0, double verticalBlackBarHeight = 0)
            {
                __Internal.SetResolution_0((__Instance + __PointerAdjustment), logicalWidth, logicalHeight, horizontalBlackBarWidth, verticalBlackBarHeight);
            }

            // <summary>
            // <para>Prepares the graphics object for drawing. Nothing must be drawn</para>
            // <para>without calling begin.</para>
            // </summary>
            public bool Begin(Gosu.Color clearWithColor)
            {
                var __arg0 = ReferenceEquals(clearWithColor, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) clearWithColor.__Instance;
                var __ret = __Internal.Begin_0((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            // <summary>
            // <para>Every call to begin must have a matching call to end.</para>
            // </summary>
            public void End()
            {
                __Internal.End_0((__Instance + __PointerAdjustment));
            }

            // <summary>
            // <para>For internal use only.</para>
            // </summary>
            public void SetPhysicalResolution(uint physicalWidth, uint physicalHeight)
            {
                __Internal.SetPhysicalResolution_0((__Instance + __PointerAdjustment), physicalWidth, physicalHeight);
            }

            // <summary>
            // <para>Prepares the graphics object for drawing. Nothing must be drawn</para>
            // <para>without calling begin.</para>
            // </summary>
            public bool Begin()
            {
                return Begin(Color.BLACK);
            }

            // <summary>
            // <para>Flushes the Z queue to the screen and starts a new one.</para>
            // <para>Useful for games that are *very* composite in nature (splitscreen).</para>
            // </summary>
            public static void Flush()
            {
                __Internal.Flush_0();
            }

            // <summary>
            // <para>Finishes all pending Gosu drawing operations and executes</para>
            // <para>the following OpenGL code in a clean environment.</para>
            // </summary>
            public static void BeginGL()
            {
                __Internal.BeginGL_0();
            }

            // <summary>
            // <para>Resets Gosu into its default rendering state.</para>
            // </summary>
            public static void EndGL()
            {
                __Internal.EndGL_0();
            }

            // <summary>
            // <para>Enables clipping to a specified rectangle.</para>
            // </summary>
            public static void BeginClipping(double x, double y, double width, double height)
            {
                __Internal.BeginClipping_0(x, y, width, height);
            }

            // <summary>
            // <para>Disables clipping.</para>
            // </summary>
            public static void EndClipping()
            {
                __Internal.EndClipping_0();
            }

            // <summary>
            // <para>Starts recording a macro. Cannot be nested.</para>
            // </summary>
            public static void BeginRecording()
            {
                __Internal.BeginRecording_0();
            }

            // <summary>
            // <para>Pops one transformation from the transformation stack.</para>
            // </summary>
            public static void PopTransform()
            {
                __Internal.PopTransform_0();
            }

            // <summary>
            // <para>Draws a line from one point to another (last pixel exclusive).</para>
            // <para>Note: OpenGL lines are not reliable at all and may have a missing pixel at the start</para>
            // <para>or end point. Please only use this for debugging purposes. Otherwise, use a quad or</para>
            // <para>image to simulate lines, or contribute a better drawLine to Gosu.</para>
            // </summary>
            public static void DrawLine(double x1, double y1, Gosu.Color c1, double x2, double y2, Gosu.Color c2, double z, Gosu.AlphaMode mode)
            {
                var __arg2 = ReferenceEquals(c1, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c1.__Instance;
                var __arg5 = ReferenceEquals(c2, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c2.__Instance;
                var __arg7 = mode;
                __Internal.DrawLine_0(x1, y1, __arg2, x2, y2, __arg5, z, __arg7);
            }

            public static void DrawTriangle(double x1, double y1, Gosu.Color c1, double x2, double y2, Gosu.Color c2, double x3, double y3, Gosu.Color c3, double z, Gosu.AlphaMode mode)
            {
                var __arg2 = ReferenceEquals(c1, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c1.__Instance;
                var __arg5 = ReferenceEquals(c2, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c2.__Instance;
                var __arg8 = ReferenceEquals(c3, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c3.__Instance;
                var __arg10 = mode;
                __Internal.DrawTriangle_0(x1, y1, __arg2, x2, y2, __arg5, x3, y3, __arg8, z, __arg10);
            }

            public static void DrawQuad(double x1, double y1, Gosu.Color c1, double x2, double y2, Gosu.Color c2, double x3, double y3, Gosu.Color c3, double x4, double y4, Gosu.Color c4, double z, Gosu.AlphaMode mode)
            {
                var __arg2 = ReferenceEquals(c1, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c1.__Instance;
                var __arg5 = ReferenceEquals(c2, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c2.__Instance;
                var __arg8 = ReferenceEquals(c3, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c3.__Instance;
                var __arg11 = ReferenceEquals(c4, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c4.__Instance;
                var __arg13 = mode;
                __Internal.DrawQuad_0(x1, y1, __arg2, x2, y2, __arg5, x3, y3, __arg8, x4, y4, __arg11, z, __arg13);
            }

            // <summary>
            // <para>Draws a line from one point to another (last pixel exclusive).</para>
            // <para>Note: OpenGL lines are not reliable at all and may have a missing pixel at the start</para>
            // <para>or end point. Please only use this for debugging purposes. Otherwise, use a quad or</para>
            // <para>image to simulate lines, or contribute a better drawLine to Gosu.</para>
            // </summary>
            public static void DrawLine(double x1, double y1, Gosu.Color c1, double x2, double y2, Gosu.Color c2, double z)
            {
                DrawLine(x1, y1, c1, x2, y2, c2, z, Gosu.GraphicsBase.AmDefault);
            }

            public static void DrawTriangle(double x1, double y1, Gosu.Color c1, double x2, double y2, Gosu.Color c2, double x3, double y3, Gosu.Color c3, double z)
            {
                DrawTriangle(x1, y1, c1, x2, y2, c2, x3, y3, c3, z, Gosu.GraphicsBase.AmDefault);
            }

            public static void DrawQuad(double x1, double y1, Gosu.Color c1, double x2, double y2, Gosu.Color c2, double x3, double y3, Gosu.Color c3, double x4, double y4, Gosu.Color c4, double z)
            {
                DrawQuad(x1, y1, c1, x2, y2, c2, x3, y3, c3, x4, y4, c4, z, Gosu.GraphicsBase.AmDefault);
            }

            public uint Width
            {
                get
                {
                    var __ret = __Internal.Width_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint Height
            {
                get
                {
                    var __ret = __Internal.Height_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool Fullscreen
            {
                get
                {
                    var __ret = __Internal.Fullscreen_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        public unsafe partial class Graphics
        {
            public partial struct __Internal
            {
            }

            // <summary>
            // <para>Returns the maximum size of an texture that will be allocated</para>
            // <para>internally by Gosu.</para>
            // <para>Useful when extending Gosu using OpenGL.</para>
            // </summary>
            public static uint MAX_TEXTURE_SIZE
            {
                get
                {
                    var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?MAX_TEXTURE_SIZE@Gosu@@3IB");
                    return *__ptr;
                }
            }
        }
    }

    namespace Gosu
    {
        // <summary>
        // <para>Represents an RGBA color value with 8 bits for each channel. Can be</para>
        // <para>implicitly constructed from literals of the form 0xaarrggbb. Has fast</para>
        // <para>value semantics.</para>
        // <para>The four-byte layout in memory is RGBA. On Big-Endian machines the</para>
        // <para>unsigned int interpretation is 0xrrggbbaa, on Little-Endian machines</para>
        // <para>it is 0xaabbggrr.</para>
        // </summary>
        public unsafe partial class Color : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                public uint rep;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Color@Gosu@@QAE@XZ")]
                internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Color@Gosu@@QAE@I@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, uint argb);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Color@Gosu@@QAE@EEE@Z")]
                internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, byte red, byte green, byte blue);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Color@Gosu@@QAE@EEEE@Z")]
                internal static extern global::System.IntPtr ctor_3(global::System.IntPtr instance, byte alpha, byte red, byte green, byte blue);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Color@Gosu@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromHSV@Color@Gosu@@SA?AV12@NNN@Z")]
                internal static extern void FromHSV_0(global::System.IntPtr @return, double h, double s, double v);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromAHSV@Color@Gosu@@SA?AV12@ENNN@Z")]
                internal static extern void FromAHSV_0(global::System.IntPtr @return, byte alpha, double h, double s, double v);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??MGosu@@YA_NVColor@0@0@Z")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorLess_0(Gosu.Color.__Internal a, Gosu.Color.__Internal b);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??8Gosu@@YA_NVColor@0@0@Z")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(Gosu.Color.__Internal a, Gosu.Color.__Internal b);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??9Gosu@@YA_NVColor@0@0@Z")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(Gosu.Color.__Internal a, Gosu.Color.__Internal b);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?red@Color@Gosu@@QBEEXZ")]
                internal static extern byte Red_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setRed@Color@Gosu@@QAEXE@Z")]
                internal static extern void SetRed_0(global::System.IntPtr instance, byte value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?green@Color@Gosu@@QBEEXZ")]
                internal static extern byte Green_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setGreen@Color@Gosu@@QAEXE@Z")]
                internal static extern void SetGreen_0(global::System.IntPtr instance, byte value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?blue@Color@Gosu@@QBEEXZ")]
                internal static extern byte Blue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setBlue@Color@Gosu@@QAEXE@Z")]
                internal static extern void SetBlue_0(global::System.IntPtr instance, byte value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?alpha@Color@Gosu@@QBEEXZ")]
                internal static extern byte Alpha_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setAlpha@Color@Gosu@@QAEXE@Z")]
                internal static extern void SetAlpha_0(global::System.IntPtr instance, byte value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?hue@Color@Gosu@@QBENXZ")]
                internal static extern double Hue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setHue@Color@Gosu@@QAEXN@Z")]
                internal static extern void SetHue_0(global::System.IntPtr instance, double h);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?saturation@Color@Gosu@@QBENXZ")]
                internal static extern double Saturation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setSaturation@Color@Gosu@@QAEXN@Z")]
                internal static extern void SetSaturation_0(global::System.IntPtr instance, double s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?value@Color@Gosu@@QBENXZ")]
                internal static extern double Value_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setValue@Color@Gosu@@QAEXN@Z")]
                internal static extern void SetValue_0(global::System.IntPtr instance, double v);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?argb@Color@Gosu@@QBEIXZ")]
                internal static extern uint Argb_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?bgr@Color@Gosu@@QBEIXZ")]
                internal static extern uint Bgr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?abgr@Color@Gosu@@QBEIXZ")]
                internal static extern uint Abgr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?gl@Color@Gosu@@QBEIXZ")]
                internal static extern uint Gl_0(global::System.IntPtr instance);
            }

            internal enum _0
            {
                RED_OFFSET = 0,
                GREEN_OFFSET = 8,
                BLUE_OFFSET = 16,
                ALPHA_OFFSET = 24
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Color> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Color>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static Color __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new Color(native.ToPointer(), skipVTables);
            }

            public static Color __CreateInstance(Color.__Internal native, bool skipVTables = false)
            {
                return new Color(native, skipVTables);
            }

            private static void* __CopyValue(Color.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(4);
                *(Color.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Color(Color.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Color(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            // <summary>
            // <para>The default constructor does not initialize the color to any value.</para>
            // </summary>
            public Color()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor_0((__Instance + __PointerAdjustment));
            }

            // <summary>
            // <para>Conversion constructor for literals of the form 0xaarrggbb.</para>
            // </summary>
            public Color(uint argb)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor_1((__Instance + __PointerAdjustment), argb);
            }

            public Color(byte red, byte green, byte blue)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor_2((__Instance + __PointerAdjustment), red, green, blue);
            }

            public Color(byte alpha, byte red, byte green, byte blue)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor_3((__Instance + __PointerAdjustment), alpha, red, green, blue);
            }

            public Color(Gosu.Color _0)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((Color.__Internal*) __Instance) = *((Color.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                Gosu.Color __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static bool operator >(Gosu.Color a, Gosu.Color b)
            {
                return !(a < b);
            }

            public static implicit operator Gosu.Color(uint argb)
            {
                return new Gosu.Color(argb);
            }

            // <summary>
            // <para>Constructs a color from the given hue/saturation/value triple.</para>
            // <para>Ranges of these values are given as 0..360, 0..1 and 0..1,</para>
            // <para>respectively.</para>
            // <para>The alpha value is set to 1 from this method.</para>
            // </summary>
            public static Gosu.Color FromHSV(double h, double s, double v)
            {
                var __ret = new Gosu.Color.__Internal();
                __Internal.FromHSV_0(new IntPtr(&__ret), h, s, v);
                return Gosu.Color.__CreateInstance(__ret);
            }

            public static Gosu.Color FromAHSV(byte alpha, double h, double s, double v)
            {
                var __ret = new Gosu.Color.__Internal();
                __Internal.FromAHSV_0(new IntPtr(&__ret), alpha, h, s, v);
                return Gosu.Color.__CreateInstance(__ret);
            }

            public static bool operator <(Gosu.Color a, Gosu.Color b)
            {
                var __arg0 = ReferenceEquals(a, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) a.__Instance;
                var __arg1 = ReferenceEquals(b, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) b.__Instance;
                var __ret = __Internal.OperatorLess_0(__arg0, __arg1);
                return __ret;
            }

            public static bool operator ==(Gosu.Color a, Gosu.Color b)
            {
                bool aNull = ReferenceEquals(a, null);
                bool bNull = ReferenceEquals(b, null);
                if (aNull || bNull)
                    return aNull && bNull;
                var __arg0 = ReferenceEquals(a, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) a.__Instance;
                var __arg1 = ReferenceEquals(b, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) b.__Instance;
                var __ret = __Internal.OperatorEqualEqual_0(__arg0, __arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as Color;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(Gosu.Color a, Gosu.Color b)
            {
                bool aNull = ReferenceEquals(a, null);
                bool bNull = ReferenceEquals(b, null);
                if (aNull || bNull)
                    return !(aNull && bNull);
                var __arg0 = ReferenceEquals(a, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) a.__Instance;
                var __arg1 = ReferenceEquals(b, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) b.__Instance;
                var __ret = __Internal.OperatorExclaimEqual_0(__arg0, __arg1);
                return __ret;
            }

            public static uint GL_FORMAT
            {
                get
                {
                    var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?GL_FORMAT@Color@Gosu@@2IB");
                    return *__ptr;
                }
            }

            public static Gosu.Color NONE
            {
                get
                {
                    var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?NONE@Color@Gosu@@2V12@B");
                    return Gosu.Color.__CreateInstance(*__ptr);
                }
            }

            public static Gosu.Color BLACK
            {
                get
                {
                    var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?BLACK@Color@Gosu@@2V12@B");
                    return Gosu.Color.__CreateInstance(*__ptr);
                }
            }

            public static Gosu.Color GRAY
            {
                get
                {
                    var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?GRAY@Color@Gosu@@2V12@B");
                    return Gosu.Color.__CreateInstance(*__ptr);
                }
            }

            public static Gosu.Color WHITE
            {
                get
                {
                    var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?WHITE@Color@Gosu@@2V12@B");
                    return Gosu.Color.__CreateInstance(*__ptr);
                }
            }

            public static Gosu.Color AQUA
            {
                get
                {
                    var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?AQUA@Color@Gosu@@2V12@B");
                    return Gosu.Color.__CreateInstance(*__ptr);
                }
            }

            public static Gosu.Color RED
            {
                get
                {
                    var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?RED@Color@Gosu@@2V12@B");
                    return Gosu.Color.__CreateInstance(*__ptr);
                }
            }

            public static Gosu.Color GREEN
            {
                get
                {
                    var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?GREEN@Color@Gosu@@2V12@B");
                    return Gosu.Color.__CreateInstance(*__ptr);
                }
            }

            public static Gosu.Color BLUE
            {
                get
                {
                    var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?BLUE@Color@Gosu@@2V12@B");
                    return Gosu.Color.__CreateInstance(*__ptr);
                }
            }

            public static Gosu.Color YELLOW
            {
                get
                {
                    var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?YELLOW@Color@Gosu@@2V12@B");
                    return Gosu.Color.__CreateInstance(*__ptr);
                }
            }

            public static Gosu.Color FUCHSIA
            {
                get
                {
                    var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?FUCHSIA@Color@Gosu@@2V12@B");
                    return Gosu.Color.__CreateInstance(*__ptr);
                }
            }

            public static Gosu.Color CYAN
            {
                get
                {
                    var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?CYAN@Color@Gosu@@2V12@B");
                    return Gosu.Color.__CreateInstance(*__ptr);
                }
            }

            public byte Red
            {
                get
                {
                    var __ret = __Internal.Red_0((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetRed_0((__Instance + __PointerAdjustment), value);
                }
            }

            public byte Green
            {
                get
                {
                    var __ret = __Internal.Green_0((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetGreen_0((__Instance + __PointerAdjustment), value);
                }
            }

            public byte Blue
            {
                get
                {
                    var __ret = __Internal.Blue_0((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetBlue_0((__Instance + __PointerAdjustment), value);
                }
            }

            public byte Alpha
            {
                get
                {
                    var __ret = __Internal.Alpha_0((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetAlpha_0((__Instance + __PointerAdjustment), value);
                }
            }

            // <summary>
            // <para>Returns the hue of the color, in the usual range of 0..360.</para>
            // </summary>
            // <remarks>
            // <para>Changes the current color so hue() will return h.</para>
            // </remarks>
            public double Hue
            {
                get
                {
                    var __ret = __Internal.Hue_0((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetHue_0((__Instance + __PointerAdjustment), value);
                }
            }

            // <summary>
            // <para>Returns the saturation of the color, in the range of 0..1.</para>
            // </summary>
            // <remarks>
            // <para>Changes the current color so saturation() will return s.</para>
            // </remarks>
            public double Saturation
            {
                get
                {
                    var __ret = __Internal.Saturation_0((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetSaturation_0((__Instance + __PointerAdjustment), value);
                }
            }

            // <summary>
            // <para>Returns the value (brightness) of the color, in the range of 0..1.</para>
            // </summary>
            // <remarks>
            // <para>Changes the current color so value() will return v.</para>
            // </remarks>
            public double Value
            {
                get
                {
                    var __ret = __Internal.Value_0((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetValue_0((__Instance + __PointerAdjustment), value);
                }
            }

            // <summary>
            // <para>Returns the color in 0xaarrggbb representation.</para>
            // </summary>
            public uint Argb
            {
                get
                {
                    var __ret = __Internal.Argb_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            // <summary>
            // <para>Returns the color in 0x00bbggrr representation. Useful for Win32 programming.</para>
            // </summary>
            public uint Bgr
            {
                get
                {
                    var __ret = __Internal.Bgr_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            // <summary>
            // <para>Returns the color in 0xaabbggrr representation.</para>
            // </summary>
            public uint Abgr
            {
                get
                {
                    var __ret = __Internal.Abgr_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            // <summary>
            // <para>Returns the internal representation of the color (RGBA in memory).</para>
            // </summary>
            public uint Gl
            {
                get
                {
                    var __ret = __Internal.Gl_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        public unsafe partial class Color
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?interpolate@Gosu@@YA?AVColor@1@V21@0N@Z")]
                internal static extern void Interpolate_0(global::System.IntPtr @return, Gosu.Color.__Internal a, Gosu.Color.__Internal b, double weight);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?multiply@Gosu@@YA?AVColor@1@V21@0@Z")]
                internal static extern void Multiply_0(global::System.IntPtr @return, Gosu.Color.__Internal a, Gosu.Color.__Internal b);
            }

            // <summary>
            // <para>Interpolates linearly between two colors, with a given weight towards</para>
            // <para>the second color.</para>
            // <para>Specialization of the general function in Gosu/Math.hpp.</para>
            // </summary>
            public static Gosu.Color Interpolate(Gosu.Color a, Gosu.Color b, double weight = 0.5)
            {
                var __arg0 = ReferenceEquals(a, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) a.__Instance;
                var __arg1 = ReferenceEquals(b, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) b.__Instance;
                var __ret = new Gosu.Color.__Internal();
                __Internal.Interpolate_0(new IntPtr(&__ret), __arg0, __arg1, weight);
                return Gosu.Color.__CreateInstance(__ret);
            }

            // <summary>
            // <para>Combines two colors as if their channels were mapped to the 0..1 range</para>
            // <para>and then multiplied with each other.</para>
            // </summary>
            public static Gosu.Color Multiply(Gosu.Color a, Gosu.Color b)
            {
                var __arg0 = ReferenceEquals(a, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) a.__Instance;
                var __arg1 = ReferenceEquals(b, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) b.__Instance;
                var __ret = new Gosu.Color.__Internal();
                __Internal.Multiply_0(new IntPtr(&__ret), __arg0, __arg1);
                return Gosu.Color.__CreateInstance(__ret);
            }
        }

        namespace Colors
        {
            public unsafe partial class Color
            {
                public partial struct __Internal
                {
                }

                public static Gosu.Color None
                {
                    get
                    {
                        var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?none@Colors@Gosu@@3VColor@2@B");
                        return Gosu.Color.__CreateInstance(*__ptr);
                    }
                }

                public static Gosu.Color Black
                {
                    get
                    {
                        var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?black@Colors@Gosu@@3VColor@2@B");
                        return Gosu.Color.__CreateInstance(*__ptr);
                    }
                }

                public static Gosu.Color Gray
                {
                    get
                    {
                        var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?gray@Colors@Gosu@@3VColor@2@B");
                        return Gosu.Color.__CreateInstance(*__ptr);
                    }
                }

                public static Gosu.Color White
                {
                    get
                    {
                        var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?white@Colors@Gosu@@3VColor@2@B");
                        return Gosu.Color.__CreateInstance(*__ptr);
                    }
                }

                public static Gosu.Color Aqua
                {
                    get
                    {
                        var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?aqua@Colors@Gosu@@3VColor@2@B");
                        return Gosu.Color.__CreateInstance(*__ptr);
                    }
                }

                public static Gosu.Color Red
                {
                    get
                    {
                        var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?red@Colors@Gosu@@3VColor@2@B");
                        return Gosu.Color.__CreateInstance(*__ptr);
                    }
                }

                public static Gosu.Color Green
                {
                    get
                    {
                        var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?green@Colors@Gosu@@3VColor@2@B");
                        return Gosu.Color.__CreateInstance(*__ptr);
                    }
                }

                public static Gosu.Color Blue
                {
                    get
                    {
                        var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?blue@Colors@Gosu@@3VColor@2@B");
                        return Gosu.Color.__CreateInstance(*__ptr);
                    }
                }

                public static Gosu.Color Yellow
                {
                    get
                    {
                        var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?yellow@Colors@Gosu@@3VColor@2@B");
                        return Gosu.Color.__CreateInstance(*__ptr);
                    }
                }

                public static Gosu.Color Fuchsia
                {
                    get
                    {
                        var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?fuchsia@Colors@Gosu@@3VColor@2@B");
                        return Gosu.Color.__CreateInstance(*__ptr);
                    }
                }

                public static Gosu.Color Cyan
                {
                    get
                    {
                        var __ptr = (Gosu.Color.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?cyan@Colors@Gosu@@3VColor@2@B");
                        return Gosu.Color.__CreateInstance(*__ptr);
                    }
                }
            }
        }
    }

    namespace Gosu
    {
        public enum AlphaMode
        {
            // <summary>The color's channels will be interpolated. The alpha channel specifies the opacity of the new color, 255 is full opacity.</summary>
            DEFAULT = 0,
            // <summary>The color's channels will be interpolated. The alpha channel specifies the opacity of the new color, 255 is full opacity.</summary>
            INTERPOLATE = 0,
            // <summary>The colors' channels will be added. The alpha channel specifies the percentage of the new color's channels that will be added to the old color's channels.</summary>
            ADD = 1,
            // <summary>The color's channels will be multiplied with each other.</summary>
            MULTIPLY = 2
        }

        [Flags]
        public enum FontFlags
        {
            FfBold = 1,
            FfItalic = 2,
            FfUnderline = 4,
            FfCombinations = 8
        }

        public enum TextAlign
        {
            TaLeft = 0,
            TaRight = 1,
            TaCenter = 2,
            TaJustify = 3
        }

        // <summary>
        // <para>Flags that affect the tileability or interpolation of an image.</para>
        // </summary>
        public enum ImageFlags
        {
            IfSmooth = 0,
            IfTileableLeft = 2,
            IfTileableTop = 4,
            IfTileableRight = 8,
            IfTileableBottom = 16,
            IfTileable = 30,
            // <summary>Apply nearest-neighbor interpolation when scaling this image up or down.</summary>
            IfRetro = 32
        }

    }

    namespace Gosu
    {
        // <summary>
        // <para>Provides functionality for drawing rectangular images.</para>
        // </summary>
        public unsafe partial class Image : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Std.SharedPtr.__Internal data;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Image@Gosu@@QAE@PBDI@Z")]
                internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string filename, uint imageFlags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Image@Gosu@@QAE@PBDIIIII@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string filename, uint srcX, uint srcY, uint srcWidth, uint srcHeight, uint imageFlags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Image@Gosu@@QAE@ABVBitmap@1@I@Z")]
                internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, global::System.IntPtr source, uint imageFlags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Image@Gosu@@QAE@ABVBitmap@1@IIIII@Z")]
                internal static extern global::System.IntPtr ctor_3(global::System.IntPtr instance, global::System.IntPtr source, uint srcX, uint srcY, uint srcWidth, uint srcHeight, uint imageFlags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Image@Gosu@@QAE@AAVGraphics@1@PBD_N@Z")]
                internal static extern global::System.IntPtr ctor_5(global::System.IntPtr instance, global::System.IntPtr graphics, [MarshalAs(UnmanagedType.LPStr)] string filename, bool tileable);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Image@Gosu@@QAE@AAVGraphics@1@PBDIIII_N@Z")]
                internal static extern global::System.IntPtr ctor_6(global::System.IntPtr instance, global::System.IntPtr graphics, [MarshalAs(UnmanagedType.LPStr)] string filename, uint srcX, uint srcY, uint srcWidth, uint srcHeight, bool tileable);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Image@Gosu@@QAE@AAVGraphics@1@ABVBitmap@1@_N@Z")]
                internal static extern global::System.IntPtr ctor_7(global::System.IntPtr instance, global::System.IntPtr graphics, global::System.IntPtr source, bool tileable);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Image@Gosu@@QAE@AAVGraphics@1@ABVBitmap@1@IIII_N@Z")]
                internal static extern global::System.IntPtr ctor_8(global::System.IntPtr instance, global::System.IntPtr graphics, global::System.IntPtr source, uint srcX, uint srcY, uint srcWidth, uint srcHeight, bool tileable);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Image@Gosu@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_10(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??1Image@Gosu@@QAE@XZ")]
                internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?draw@Image@Gosu@@QBEXNNNNNVColor@2@W4AlphaMode@2@@Z")]
                internal static extern void Draw_0(global::System.IntPtr instance, double x, double y, double z, double factorX, double factorY, Gosu.Color.__Internal c, Gosu.AlphaMode mode);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?drawMod@Image@Gosu@@QBEXNNNNNVColor@2@000W4AlphaMode@2@@Z")]
                internal static extern void DrawMod_0(global::System.IntPtr instance, double x, double y, double z, double factorX, double factorY, Gosu.Color.__Internal c1, Gosu.Color.__Internal c2, Gosu.Color.__Internal c3, Gosu.Color.__Internal c4, Gosu.AlphaMode mode);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?drawRot@Image@Gosu@@QBEXNNNNNNNNVColor@2@W4AlphaMode@2@@Z")]
                internal static extern void DrawRot_0(global::System.IntPtr instance, double x, double y, double z, double angle, double centerX, double centerY, double factorX, double factorY, Gosu.Color.__Internal c, Gosu.AlphaMode mode);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?width@Image@Gosu@@QBEIXZ")]
                internal static extern uint Width_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?height@Image@Gosu@@QBEIXZ")]
                internal static extern uint Height_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Image> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Image>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static Image __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new Image(native.ToPointer(), skipVTables);
            }

            public static Image __CreateInstance(Image.__Internal native, bool skipVTables = false)
            {
                return new Image(native, skipVTables);
            }

            private static void* __CopyValue(Image.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(8);
                Gosu.Image.__Internal.cctor_10(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private Image(Image.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Image(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            // <summary>
            // <para>Loads an image from a given filename.</para>
            // </summary>
            // <remarks>
            // <para>A color key of #ff00ff is automatically applied to BMP image files.</para>
            // <para>For more flexibility, use the corresponding constructor that uses a Bitmap object.</para>
            // </remarks>
            public Image(string filename, uint imageFlags = (int) Gosu.ImageFlags.IfSmooth)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = filename;
                __Internal.ctor_0((__Instance + __PointerAdjustment), __arg0, imageFlags);
            }

            // <summary>
            // <para>Loads a portion of the the image at the given filename..</para>
            // </summary>
            // <remarks>
            // <para>A color key of #ff00ff is automatically applied to BMP image files.</para>
            // <para>For more flexibility, use the corresponding constructor that uses a Bitmap object.</para>
            // </remarks>
            public Image(string filename, uint srcX, uint srcY, uint srcWidth, uint srcHeight, uint imageFlags = (int) Gosu.ImageFlags.IfSmooth)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = filename;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0, srcX, srcY, srcWidth, srcHeight, imageFlags);
            }

            // <summary>
            // <para>Converts the given bitmap into an image.</para>
            // </summary>
            public Image(Gosu.Bitmap source, uint imageFlags = (int) Gosu.ImageFlags.IfSmooth)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(source, null))
                    throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = source.__Instance;
                __Internal.ctor_2((__Instance + __PointerAdjustment), __arg0, imageFlags);
            }

            // <summary>
            // <para>Converts a portion of the given bitmap into an image.</para>
            // </summary>
            public Image(Gosu.Bitmap source, uint srcX, uint srcY, uint srcWidth, uint srcHeight, uint imageFlags = (int) Gosu.ImageFlags.IfSmooth)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(source, null))
                    throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = source.__Instance;
                __Internal.ctor_3((__Instance + __PointerAdjustment), __arg0, srcX, srcY, srcWidth, srcHeight, imageFlags);
            }

            public Image(Gosu.Graphics graphics, string filename, bool tileable = false)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(graphics, null))
                    throw new global::System.ArgumentNullException("graphics", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = graphics.__Instance;
                var __arg1 = filename;
                __Internal.ctor_5((__Instance + __PointerAdjustment), __arg0, __arg1, tileable);
            }

            public Image(Gosu.Graphics graphics, string filename, uint srcX, uint srcY, uint srcWidth, uint srcHeight, bool tileable = false)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(graphics, null))
                    throw new global::System.ArgumentNullException("graphics", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = graphics.__Instance;
                var __arg1 = filename;
                __Internal.ctor_6((__Instance + __PointerAdjustment), __arg0, __arg1, srcX, srcY, srcWidth, srcHeight, tileable);
            }

            public Image(Gosu.Graphics graphics, Gosu.Bitmap source, bool tileable = false)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(graphics, null))
                    throw new global::System.ArgumentNullException("graphics", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = graphics.__Instance;
                if (ReferenceEquals(source, null))
                    throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = source.__Instance;
                __Internal.ctor_7((__Instance + __PointerAdjustment), __arg0, __arg1, tileable);
            }

            public Image(Gosu.Graphics graphics, Gosu.Bitmap source, uint srcX, uint srcY, uint srcWidth, uint srcHeight, bool tileable = false)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(graphics, null))
                    throw new global::System.ArgumentNullException("graphics", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = graphics.__Instance;
                if (ReferenceEquals(source, null))
                    throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = source.__Instance;
                __Internal.ctor_8((__Instance + __PointerAdjustment), __arg0, __arg1, srcX, srcY, srcWidth, srcHeight, tileable);
            }

            public Image(Gosu.Image _0)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_10((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                Gosu.Image __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            // <summary>
            // <para>Draws the image so its upper left corner is at (x; y).</para>
            // </summary>
            public void Draw(double x, double y, double z, double factorX, double factorY, Gosu.Color c, Gosu.AlphaMode mode)
            {
                var __arg5 = ReferenceEquals(c, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c.__Instance;
                var __arg6 = mode;
                __Internal.Draw_0((__Instance + __PointerAdjustment), x, y, z, factorX, factorY, __arg5, __arg6);
            }

            // <summary>
            // <para>Like draw(), but with modulation colors for all four corners.</para>
            // <para>TODO: This can be an overload of draw() - in any case the name is terrible.</para>
            // </summary>
            public void DrawMod(double x, double y, double z, double factorX, double factorY, Gosu.Color c1, Gosu.Color c2, Gosu.Color c3, Gosu.Color c4, Gosu.AlphaMode mode)
            {
                var __arg5 = ReferenceEquals(c1, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c1.__Instance;
                var __arg6 = ReferenceEquals(c2, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c2.__Instance;
                var __arg7 = ReferenceEquals(c3, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c3.__Instance;
                var __arg8 = ReferenceEquals(c4, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c4.__Instance;
                var __arg9 = mode;
                __Internal.DrawMod_0((__Instance + __PointerAdjustment), x, y, z, factorX, factorY, __arg5, __arg6, __arg7, __arg8, __arg9);
            }

            // <summary>
            // <para>Draws the image rotated by the given angle so that its rotation</para>
            // <para>center is at (x; y). Note that this is different from how all the</para>
            // <para>other drawing functions work!</para>
            // </summary>
            // <param name="angle">
            // <para>See Math.hpp for an explanation of how Gosu interprets</para>
            // <para>angles.</para>
            // </param>
            // <param name="centerX">
            // <para>Relative horizontal position of the rotation center</para>
            // <para>on the image. 0 is the left border, 1 is the right border, 0.5 is</para>
            // <para>the center (and default).</para>
            // </param>
            // <param name="centerY">
            // <para>See centerX.</para>
            // </param>
            public void DrawRot(double x, double y, double z, double angle, double centerX, double centerY, double factorX, double factorY, Gosu.Color c, Gosu.AlphaMode mode)
            {
                var __arg8 = ReferenceEquals(c, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c.__Instance;
                var __arg9 = mode;
                __Internal.DrawRot_0((__Instance + __PointerAdjustment), x, y, z, angle, centerX, centerY, factorX, factorY, __arg8, __arg9);
            }

            public static explicit operator Gosu.Image(string filename)
            {
                return new Gosu.Image(filename);
            }

            public static explicit operator Gosu.Image(Gosu.Bitmap source)
            {
                return new Gosu.Image(source);
            }

            // <summary>
            // <para>Draws the image so its upper left corner is at (x; y).</para>
            // </summary>
            public void Draw(double x, double y, double z, double factorX = 1, double factorY = 1)
            {
                Draw(x, y, z, factorX, factorY, Color.WHITE, Gosu.GraphicsBase.AmDefault);
            }

            // <summary>
            // <para>Draws the image so its upper left corner is at (x; y).</para>
            // </summary>
            public void Draw(double x, double y, double z, double factorX, double factorY, Gosu.Color c)
            {
                Draw(x, y, z, factorX, factorY, c, Gosu.GraphicsBase.AmDefault);
            }

            // <summary>
            // <para>Like draw(), but with modulation colors for all four corners.</para>
            // <para>TODO: This can be an overload of draw() - in any case the name is terrible.</para>
            // </summary>
            public void DrawMod(double x, double y, double z, double factorX, double factorY, Gosu.Color c1, Gosu.Color c2, Gosu.Color c3, Gosu.Color c4)
            {
                DrawMod(x, y, z, factorX, factorY, c1, c2, c3, c4, Gosu.GraphicsBase.AmDefault);
            }

            // <summary>
            // <para>Draws the image rotated by the given angle so that its rotation</para>
            // <para>center is at (x; y). Note that this is different from how all the</para>
            // <para>other drawing functions work!</para>
            // </summary>
            // <param name="angle">
            // <para>See Math.hpp for an explanation of how Gosu interprets</para>
            // <para>angles.</para>
            // </param>
            // <param name="centerX">
            // <para>Relative horizontal position of the rotation center</para>
            // <para>on the image. 0 is the left border, 1 is the right border, 0.5 is</para>
            // <para>the center (and default).</para>
            // </param>
            // <param name="centerY">
            // <para>See centerX.</para>
            // </param>
            public void DrawRot(double x, double y, double z, double angle, double centerX = 0.5, double centerY = 0.5, double factorX = 1, double factorY = 1)
            {
                DrawRot(x, y, z, angle, centerX, centerY, factorX, factorY, Color.WHITE, Gosu.GraphicsBase.AmDefault);
            }

            // <summary>
            // <para>Draws the image rotated by the given angle so that its rotation</para>
            // <para>center is at (x; y). Note that this is different from how all the</para>
            // <para>other drawing functions work!</para>
            // </summary>
            // <param name="angle">
            // <para>See Math.hpp for an explanation of how Gosu interprets</para>
            // <para>angles.</para>
            // </param>
            // <param name="centerX">
            // <para>Relative horizontal position of the rotation center</para>
            // <para>on the image. 0 is the left border, 1 is the right border, 0.5 is</para>
            // <para>the center (and default).</para>
            // </param>
            // <param name="centerY">
            // <para>See centerX.</para>
            // </param>
            public void DrawRot(double x, double y, double z, double angle, double centerX, double centerY, double factorX, double factorY, Gosu.Color c)
            {
                DrawRot(x, y, z, angle, centerX, centerY, factorX, factorY, c, Gosu.GraphicsBase.AmDefault);
            }

            public uint Width
            {
                get
                {
                    var __ret = __Internal.Width_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint Height
            {
                get
                {
                    var __ret = __Internal.Height_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }
    }

    namespace Gosu
    {
        // <summary>
        // <para>Rectangular area of pixels, each represented by a Color value. Provides</para>
        // <para>minimal drawing functionality and serves as a temporary holder for</para>
        // <para>graphical resources which are usually turned into Images later.</para>
        // <para>Has (expensive) value semantics.</para>
        // </summary>
        public unsafe partial class Bitmap : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 20)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                public uint w;

                [FieldOffset(4)]
                public uint h;

                [FieldOffset(8)]
                internal global::Std.Vector.__Internal pixels;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Bitmap@Gosu@@QAE@XZ")]
                internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Bitmap@Gosu@@QAE@IIVColor@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, uint w, uint h, Gosu.Color.__Internal c);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Bitmap@Gosu@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??1Bitmap@Gosu@@QAE@XZ")]
                internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?swap@Bitmap@Gosu@@QAEXAAV12@@Z")]
                internal static extern void Swap_0(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?resize@Bitmap@Gosu@@QAEXIIVColor@2@@Z")]
                internal static extern void Resize_0(global::System.IntPtr instance, uint width, uint height, Gosu.Color.__Internal c);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getPixel@Bitmap@Gosu@@QBE?AVColor@2@II@Z")]
                internal static extern void GetPixel_0(global::System.IntPtr instance, global::System.IntPtr @return, uint x, uint y);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setPixel@Bitmap@Gosu@@QAEXIIVColor@2@@Z")]
                internal static extern void SetPixel_0(global::System.IntPtr instance, uint x, uint y, Gosu.Color.__Internal c);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?insert@Bitmap@Gosu@@QAEXABV12@HH@Z")]
                internal static extern void Insert_0(global::System.IntPtr instance, global::System.IntPtr source, int x, int y);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?insert@Bitmap@Gosu@@QAEXABV12@HHIIII@Z")]
                internal static extern void Insert_1(global::System.IntPtr instance, global::System.IntPtr source, int x, int y, uint srcX, uint srcY, uint srcWidth, uint srcHeight);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?fill@Bitmap@Gosu@@QAEXVColor@2@@Z")]
                internal static extern void Fill_0(global::System.IntPtr instance, Gosu.Color.__Internal c);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?replace@Bitmap@Gosu@@QAEXVColor@2@0@Z")]
                internal static extern void Replace_0(global::System.IntPtr instance, Gosu.Color.__Internal oldColor, Gosu.Color.__Internal newColor);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?width@Bitmap@Gosu@@QBEIXZ")]
                internal static extern uint Width_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?height@Bitmap@Gosu@@QBEIXZ")]
                internal static extern uint Height_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?data@Bitmap@Gosu@@QBEPBVColor@2@XZ")]
                internal static extern global::System.IntPtr Data_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?data@Bitmap@Gosu@@QAEPAVColor@2@XZ")]
                internal static extern global::System.IntPtr data_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Bitmap> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Bitmap>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static Bitmap __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new Bitmap(native.ToPointer(), skipVTables);
            }

            public static Bitmap __CreateInstance(Bitmap.__Internal native, bool skipVTables = false)
            {
                return new Bitmap(native, skipVTables);
            }

            private static void* __CopyValue(Bitmap.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(20);
                Gosu.Bitmap.__Internal.cctor_3(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private Bitmap(Bitmap.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Bitmap(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public Bitmap()
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor_0((__Instance + __PointerAdjustment));
            }

            public Bitmap(uint w, uint h, Gosu.Color c)
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg2 = ReferenceEquals(c, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), w, h, __arg2);
            }

            public Bitmap(Gosu.Bitmap _0)
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_3((__Instance + __PointerAdjustment), __arg0);
            }

            public Bitmap(uint w, uint h) : this(w, h, Color.NONE)
            {
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                Gosu.Bitmap __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public void Swap(Gosu.Bitmap other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.Swap_0((__Instance + __PointerAdjustment), __arg0);
            }

            public void Resize(uint width, uint height, Gosu.Color c)
            {
                var __arg2 = ReferenceEquals(c, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c.__Instance;
                __Internal.Resize_0((__Instance + __PointerAdjustment), width, height, __arg2);
            }

            // <summary>
            // <para>Returns the color at the specified position. x and y must be on the</para>
            // <para>bitmap.</para>
            // </summary>
            public Gosu.Color GetPixel(uint x, uint y)
            {
                var __ret = new Gosu.Color.__Internal();
                __Internal.GetPixel_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), x, y);
                return Gosu.Color.__CreateInstance(__ret);
            }

            // <summary>
            // <para>Sets the pixel at the specified position to a color. x and y must</para>
            // <para>be on the bitmap.</para>
            // </summary>
            public void SetPixel(uint x, uint y, Gosu.Color c)
            {
                var __arg2 = ReferenceEquals(c, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c.__Instance;
                __Internal.SetPixel_0((__Instance + __PointerAdjustment), x, y, __arg2);
            }

            // <summary>
            // <para>Inserts a bitmap at the given position. Parts of the inserted</para>
            // <para>bitmap that would be outside of the target bitmap will be</para>
            // <para>clipped away.</para>
            // </summary>
            public void Insert(Gosu.Bitmap source, int x, int y)
            {
                if (ReferenceEquals(source, null))
                    throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = source.__Instance;
                __Internal.Insert_0((__Instance + __PointerAdjustment), __arg0, x, y);
            }

            // <summary>
            // <para>Inserts a portion of a bitmap at the given position. Parts of the</para>
            // <para>inserted bitmap that would be outside of the target bitmap will be</para>
            // <para>clipped away.</para>
            // </summary>
            public void Insert(Gosu.Bitmap source, int x, int y, uint srcX, uint srcY, uint srcWidth, uint srcHeight)
            {
                if (ReferenceEquals(source, null))
                    throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = source.__Instance;
                __Internal.Insert_1((__Instance + __PointerAdjustment), __arg0, x, y, srcX, srcY, srcWidth, srcHeight);
            }

            public void Fill(Gosu.Color c)
            {
                var __arg0 = ReferenceEquals(c, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c.__Instance;
                __Internal.Fill_0((__Instance + __PointerAdjustment), __arg0);
            }

            public void Replace(Gosu.Color oldColor, Gosu.Color newColor)
            {
                var __arg0 = ReferenceEquals(oldColor, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) oldColor.__Instance;
                var __arg1 = ReferenceEquals(newColor, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) newColor.__Instance;
                __Internal.Replace_0((__Instance + __PointerAdjustment), __arg0, __arg1);
            }

            public void Resize(uint width, uint height)
            {
                Resize(width, height, Color.NONE);
            }

            public uint Width
            {
                get
                {
                    var __ret = __Internal.Width_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint Height
            {
                get
                {
                    var __ret = __Internal.Height_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            // <summary>
            // <para>Direct access to the array of color values. May be useful for optimized</para>
            // <para>OpenGL operations.</para>
            // </summary>
            public Gosu.Color Data
            {
                get
                {
                    var __ret = __Internal.Data_0((__Instance + __PointerAdjustment));
                    Gosu.Color __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (Gosu.Color.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (Gosu.Color) Gosu.Color.NativeToManagedMap[__ret];
                    else __result0 = Gosu.Color.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public Gosu.Color data
            {
                get
                {
                    var __ret = __Internal.data_0((__Instance + __PointerAdjustment));
                    Gosu.Color __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (Gosu.Color.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (Gosu.Color) Gosu.Color.NativeToManagedMap[__ret];
                    else __result0 = Gosu.Color.__CreateInstance(__ret);
                    return __result0;
                }
            }
        }

        public unsafe partial class Bitmap
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?loadImageFile@Gosu@@YAXAAVBitmap@1@PBD@Z")]
                internal static extern void LoadImageFile_0(global::System.IntPtr bitmap, [MarshalAs(UnmanagedType.LPStr)] string filename);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?saveImageFile@Gosu@@YAXABVBitmap@1@PBD@Z")]
                internal static extern void SaveImageFile_0(global::System.IntPtr bitmap, [MarshalAs(UnmanagedType.LPStr)] string filename);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?applyColorKey@Gosu@@YAXAAVBitmap@1@VColor@1@@Z")]
                internal static extern void ApplyColorKey_0(global::System.IntPtr bitmap, Gosu.Color.__Internal key);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?unapplyColorKey@Gosu@@YAXAAVBitmap@1@VColor@1@@Z")]
                internal static extern void UnapplyColorKey_0(global::System.IntPtr bitmap, Gosu.Color.__Internal background);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?applyBorderFlags@Gosu@@YAXAAVBitmap@1@ABV21@IIIII@Z")]
                internal static extern void ApplyBorderFlags_0(global::System.IntPtr dest, global::System.IntPtr source, uint srcX, uint srcY, uint srcWidth, uint srcHeight, uint borderFlags);
            }

            // <summary>
            // <para>Loads any supported image into a Bitmap.</para>
            // </summary>
            public static void LoadImageFile(Gosu.Bitmap bitmap, string filename)
            {
                if (ReferenceEquals(bitmap, null))
                    throw new global::System.ArgumentNullException("bitmap", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = bitmap.__Instance;
                var __arg1 = filename;
                __Internal.LoadImageFile_0(__arg0, __arg1);
            }

            // <summary>
            // <para>Saves a Bitmap to a file.</para>
            // </summary>
            public static void SaveImageFile(Gosu.Bitmap bitmap, string filename)
            {
                if (ReferenceEquals(bitmap, null))
                    throw new global::System.ArgumentNullException("bitmap", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = bitmap.__Instance;
                var __arg1 = filename;
                __Internal.SaveImageFile_0(__arg0, __arg1);
            }

            // <summary>
            // <para>Set the alpha value of all pixels which are equal to the color key</para>
            // <para>to zero. Color values are adjusted so that no borders show up when</para>
            // <para>the image is stretched or rotated.</para>
            // </summary>
            public static void ApplyColorKey(Gosu.Bitmap bitmap, Gosu.Color key)
            {
                if (ReferenceEquals(bitmap, null))
                    throw new global::System.ArgumentNullException("bitmap", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = bitmap.__Instance;
                var __arg1 = ReferenceEquals(key, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) key.__Instance;
                __Internal.ApplyColorKey_0(__arg0, __arg1);
            }

            // <summary>
            // <para>The reverse of applyColorKey. Resets all fully transparent pixels by</para>
            // <para>a background color, makes all other pixels fully opaque.</para>
            // </summary>
            public static void UnapplyColorKey(Gosu.Bitmap bitmap, Gosu.Color background)
            {
                if (ReferenceEquals(bitmap, null))
                    throw new global::System.ArgumentNullException("bitmap", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = bitmap.__Instance;
                var __arg1 = ReferenceEquals(background, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) background.__Instance;
                __Internal.UnapplyColorKey_0(__arg0, __arg1);
            }

            public static void ApplyBorderFlags(Gosu.Bitmap dest, Gosu.Bitmap source, uint srcX, uint srcY, uint srcWidth, uint srcHeight, uint borderFlags)
            {
                if (ReferenceEquals(dest, null))
                    throw new global::System.ArgumentNullException("dest", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = dest.__Instance;
                if (ReferenceEquals(source, null))
                    throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = source.__Instance;
                __Internal.ApplyBorderFlags_0(__arg0, __arg1, srcX, srcY, srcWidth, srcHeight, borderFlags);
            }
        }
    }

    namespace Gosu
    {
        // <summary>
        // <para>A font can be used to draw text on a Graphics object very flexibly.</para>
        // <para>Fonts are ideal for small texts that change regularly. For large,</para>
        // <para>static texts you should use createBitmap and turn the result into</para>
        // <para>an image.</para>
        // </summary>
        public unsafe partial class Font : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Std.SharedPtr.__Internal pimpl;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Font@Gosu@@QAE@IPBDI@Z")]
                internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, uint fontHeight, [MarshalAs(UnmanagedType.LPStr)] string fontName, uint fontFlags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Font@Gosu@@QAE@AAVGraphics@1@PBDII@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr graphics, [MarshalAs(UnmanagedType.LPStr)] string fontName, uint fontHeight, uint fontFlags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Font@Gosu@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??1Font@Gosu@@QAE@XZ")]
                internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?textWidth@Font@Gosu@@QBENPBDN@Z")]
                internal static extern double TextWidth_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string text, double factorX);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?draw@Font@Gosu@@QBEXPBDNNNNNVColor@2@W4AlphaMode@2@@Z")]
                internal static extern void Draw_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string text, double x, double y, double z, double factorX, double factorY, Gosu.Color.__Internal c, Gosu.AlphaMode mode);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?drawRel@Font@Gosu@@QBEXPBDNNNNNNNVColor@2@W4AlphaMode@2@@Z")]
                internal static extern void DrawRel_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string text, double x, double y, double z, double relX, double relY, double factorX, double factorY, Gosu.Color.__Internal c, Gosu.AlphaMode mode);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setImage@Font@Gosu@@QAEX_WIABVImage@2@@Z")]
                internal static extern void SetImage_0(global::System.IntPtr instance, char wc, uint fontFlags, global::System.IntPtr image);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setImage@Font@Gosu@@QAEX_WABVImage@2@@Z")]
                internal static extern void SetImage_1(global::System.IntPtr instance, char wc, global::System.IntPtr image);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?drawRot@Font@Gosu@@QBEXPBDNNNNNNVColor@2@W4AlphaMode@2@@Z")]
                internal static extern void DrawRot_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string text, double x, double y, double z, double angle, double factorX, double factorY, Gosu.Color.__Internal c, Gosu.AlphaMode mode);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?name@Font@Gosu@@QBEPBDXZ")]
                internal static extern global::System.IntPtr Name_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?height@Font@Gosu@@QBEIXZ")]
                internal static extern uint Height_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?flags@Font@Gosu@@QBEIXZ")]
                internal static extern uint Flags_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Font> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Font>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static Font __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new Font(native.ToPointer(), skipVTables);
            }

            public static Font __CreateInstance(Font.__Internal native, bool skipVTables = false)
            {
                return new Font(native, skipVTables);
            }

            private static void* __CopyValue(Font.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(8);
                Gosu.Font.__Internal.cctor_3(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private Font(Font.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Font(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            // <summary>
            // <para>Constructs a font that can be drawn onto the graphics object.</para>
            // </summary>
            // <param name="fontName">
            // <para>Name of a system font, or a filename to a TTF</para>
            // <para>file (must contain '/', does not work on Linux).</para>
            // </param>
            // <param name="fontHeight">
            // <para>Height of the font, in pixels.</para>
            // </param>
            // <param name="fontFlags">
            // <para>Flags used to render individual characters of</para>
            // <para>the font.</para>
            // </param>
            public Font(uint fontHeight, string fontName = "Arial", uint fontFlags = (int) Gosu.FontFlags.FfBold)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg1 = fontName;
                __Internal.ctor_0((__Instance + __PointerAdjustment), fontHeight, __arg1, fontFlags);
            }

            public Font(Gosu.Graphics graphics, string fontName, uint fontHeight, uint fontFlags = (int) Gosu.FontFlags.FfBold)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(graphics, null))
                    throw new global::System.ArgumentNullException("graphics", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = graphics.__Instance;
                var __arg1 = fontName;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0, __arg1, fontHeight, fontFlags);
            }

            public Font(Gosu.Font _0)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_3((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                Gosu.Font __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            // <summary>
            // <para>Returns the width, in pixels, the given text would occupy if drawn.</para>
            // </summary>
            public double TextWidth(string text, double factorX = 1)
            {
                var __arg0 = text;
                var __ret = __Internal.TextWidth_0((__Instance + __PointerAdjustment), __arg0, factorX);
                return __ret;
            }

            // <summary>
            // <para>Draws text so the top left corner of the text is at (x; y).</para>
            // </summary>
            // <param name="text">
            // <para>Formatted text without line-breaks.</para>
            // </param>
            public void Draw(string text, double x, double y, double z, double factorX, double factorY, Gosu.Color c, Gosu.AlphaMode mode)
            {
                var __arg0 = text;
                var __arg6 = ReferenceEquals(c, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c.__Instance;
                var __arg7 = mode;
                __Internal.Draw_0((__Instance + __PointerAdjustment), __arg0, x, y, z, factorX, factorY, __arg6, __arg7);
            }

            // <summary>
            // <para>Draws text at a position relative to (x; y).</para>
            // </summary>
            // <param name="relX">
            // <para>Determines where the text is drawn horizontally. If</para>
            // <para>relX is 0.0, the text will be to the right of x, if it is 1.0,</para>
            // <para>the text will be to the left of x, if it is 0.5, it will be</para>
            // <para>centered on x. Of course, all real numbers are possible values.</para>
            // </param>
            // <param name="relY">
            // <para>See relX.</para>
            // </param>
            public void DrawRel(string text, double x, double y, double z, double relX, double relY, double factorX, double factorY, Gosu.Color c, Gosu.AlphaMode mode)
            {
                var __arg0 = text;
                var __arg8 = ReferenceEquals(c, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c.__Instance;
                var __arg9 = mode;
                __Internal.DrawRel_0((__Instance + __PointerAdjustment), __arg0, x, y, z, relX, relY, factorX, factorY, __arg8, __arg9);
            }

            // <summary>
            // <para>Maps a letter to a specific image instead of generating one using</para>
            // <para>Gosu's built-in text rendering. This can only be called once per</para>
            // <para>character, and the character must not have been drawn before.</para>
            // <para>This ensures that Fonts are still sort of immutable.</para>
            // </summary>
            public void SetImage(char wc, uint fontFlags, Gosu.Image image)
            {
                if (ReferenceEquals(image, null))
                    throw new global::System.ArgumentNullException("image", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = image.__Instance;
                __Internal.SetImage_0((__Instance + __PointerAdjustment), wc, fontFlags, __arg2);
            }

            // <summary>
            // <para>A shortcut for mapping a character to an image regardless of fontFlags.</para>
            // <para>Later versions might apply faux italics or faux bold to it (to be decided!).</para>
            // </summary>
            public void SetImage(char wc, Gosu.Image image)
            {
                if (ReferenceEquals(image, null))
                    throw new global::System.ArgumentNullException("image", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = image.__Instance;
                __Internal.SetImage_1((__Instance + __PointerAdjustment), wc, __arg1);
            }

            // <summary>
            // <para>DEPRECATED: Analogous to draw, but rotates the text by a given angle.</para>
            // <para>Use Graphics::pushTransform to achieve the same effect.</para>
            // </summary>
            public void DrawRot(string text, double x, double y, double z, double angle, double factorX, double factorY, Gosu.Color c, Gosu.AlphaMode mode)
            {
                var __arg0 = text;
                var __arg7 = ReferenceEquals(c, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c.__Instance;
                var __arg8 = mode;
                __Internal.DrawRot_0((__Instance + __PointerAdjustment), __arg0, x, y, z, angle, factorX, factorY, __arg7, __arg8);
            }

            public static implicit operator Gosu.Font(uint fontHeight)
            {
                return new Gosu.Font(fontHeight);
            }

            // <summary>
            // <para>Draws text so the top left corner of the text is at (x; y).</para>
            // </summary>
            // <param name="text">
            // <para>Formatted text without line-breaks.</para>
            // </param>
            public void Draw(string text, double x, double y, double z, double factorX = 1, double factorY = 1)
            {
                Draw(text, x, y, z, factorX, factorY, Color.WHITE, Gosu.GraphicsBase.AmDefault);
            }

            // <summary>
            // <para>Draws text so the top left corner of the text is at (x; y).</para>
            // </summary>
            // <param name="text">
            // <para>Formatted text without line-breaks.</para>
            // </param>
            public void Draw(string text, double x, double y, double z, double factorX, double factorY, Gosu.Color c)
            {
                Draw(text, x, y, z, factorX, factorY, c, Gosu.GraphicsBase.AmDefault);
            }

            // <summary>
            // <para>Draws text at a position relative to (x; y).</para>
            // </summary>
            // <param name="relX">
            // <para>Determines where the text is drawn horizontally. If</para>
            // <para>relX is 0.0, the text will be to the right of x, if it is 1.0,</para>
            // <para>the text will be to the left of x, if it is 0.5, it will be</para>
            // <para>centered on x. Of course, all real numbers are possible values.</para>
            // </param>
            // <param name="relY">
            // <para>See relX.</para>
            // </param>
            public void DrawRel(string text, double x, double y, double z, double relX, double relY, double factorX = 1, double factorY = 1)
            {
                DrawRel(text, x, y, z, relX, relY, factorX, factorY, Color.WHITE, Gosu.GraphicsBase.AmDefault);
            }

            // <summary>
            // <para>Draws text at a position relative to (x; y).</para>
            // </summary>
            // <param name="relX">
            // <para>Determines where the text is drawn horizontally. If</para>
            // <para>relX is 0.0, the text will be to the right of x, if it is 1.0,</para>
            // <para>the text will be to the left of x, if it is 0.5, it will be</para>
            // <para>centered on x. Of course, all real numbers are possible values.</para>
            // </param>
            // <param name="relY">
            // <para>See relX.</para>
            // </param>
            public void DrawRel(string text, double x, double y, double z, double relX, double relY, double factorX, double factorY, Gosu.Color c)
            {
                DrawRel(text, x, y, z, relX, relY, factorX, factorY, c, Gosu.GraphicsBase.AmDefault);
            }

            // <summary>
            // <para>DEPRECATED: Analogous to draw, but rotates the text by a given angle.</para>
            // <para>Use Graphics::pushTransform to achieve the same effect.</para>
            // </summary>
            public void DrawRot(string text, double x, double y, double z, double angle, double factorX = 1, double factorY = 1)
            {
                DrawRot(text, x, y, z, angle, factorX, factorY, Color.WHITE, Gosu.GraphicsBase.AmDefault);
            }

            // <summary>
            // <para>DEPRECATED: Analogous to draw, but rotates the text by a given angle.</para>
            // <para>Use Graphics::pushTransform to achieve the same effect.</para>
            // </summary>
            public void DrawRot(string text, double x, double y, double z, double angle, double factorX, double factorY, Gosu.Color c)
            {
                DrawRot(text, x, y, z, angle, factorX, factorY, c, Gosu.GraphicsBase.AmDefault);
            }

            // <summary>
            // <para>Returns the name of the font that was used to create it.</para>
            // </summary>
            public string Name
            {
                get
                {
                    var __ret = __Internal.Name_0((__Instance + __PointerAdjustment));
                    return Marshal.PtrToStringAnsi(__ret);
                }
            }

            // <summary>
            // <para>Returns the height of the font, in pixels.</para>
            // </summary>
            public uint Height
            {
                get
                {
                    var __ret = __Internal.Height_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            // <summary>
            // <para>Returns the flags used to create the font characters.</para>
            // </summary>
            public uint Flags
            {
                get
                {
                    var __ret = __Internal.Flags_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }
    }

    namespace Gosu
    {
        public unsafe partial class Text
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?defaultFontName@Gosu@@YAPBDXZ")]
                internal static extern global::System.IntPtr DefaultFontName_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?textWidth@Gosu@@YAIPBD0II@Z")]
                internal static extern uint TextWidth_0([MarshalAs(UnmanagedType.LPStr)] string text, [MarshalAs(UnmanagedType.LPStr)] string fontName, uint fontHeight, uint fontFlags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?drawText@Gosu@@YAXAAVBitmap@1@PBDHHVColor@1@1II@Z")]
                internal static extern void DrawText_0(global::System.IntPtr bitmap, [MarshalAs(UnmanagedType.LPStr)] string text, int x, int y, Gosu.Color.__Internal c, [MarshalAs(UnmanagedType.LPStr)] string fontName, uint fontHeight, uint fontFlags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?createText@Gosu@@YA?AVBitmap@1@PBD0II@Z")]
                internal static extern Gosu.Bitmap.__Internal CreateText_0([MarshalAs(UnmanagedType.LPStr)] string text, [MarshalAs(UnmanagedType.LPStr)] string fontName, uint fontHeight, uint fontFlags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?createText@Gosu@@YA?AVBitmap@1@PBD0IHIW4TextAlign@1@I@Z")]
                internal static extern Gosu.Bitmap.__Internal CreateText_1([MarshalAs(UnmanagedType.LPStr)] string text, [MarshalAs(UnmanagedType.LPStr)] string fontName, uint fontHeight, int lineSpacing, uint width, Gosu.TextAlign align, uint fontFlags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?registerEntity@Gosu@@YAXPBDABVBitmap@1@@Z")]
                internal static extern void RegisterEntity_0([MarshalAs(UnmanagedType.LPStr)] string name, global::System.IntPtr replacement);
            }

            // <summary>
            // <para>Returns the name of a neutral font that is available on the current</para>
            // <para>platform.</para>
            // </summary>
            public static string DefaultFontName()
            {
                var __ret = __Internal.DefaultFontName_0();
                return Marshal.PtrToStringAnsi(__ret);
            }

            // <summary>
            // <para>Returns the width an unformatted line of text would span on a bitmap if it were drawn using</para>
            // <para>drawText with the same arguments. This is a very low-level function that does not understand</para>
            // <para>any of Gosu's HTML-like markup.</para>
            // </summary>
            // <param name="text">
            // <para>Unformatted text.</para>
            // </param>
            // <param name="fontName">
            // <para>Name of a system font, or a filename to a TTF file (must contain '/').</para>
            // </param>
            public static uint TextWidth(string text, string fontName, uint fontHeight, uint fontFlags = 0)
            {
                var __arg0 = text;
                var __arg1 = fontName;
                var __ret = __Internal.TextWidth_0(__arg0, __arg1, fontHeight, fontFlags);
                return __ret;
            }

            // <summary>
            // <para>Draws a line of unformatted text on a bitmap. This is a very low-level function that does not understand</para>
            // <para>any of Gosu's HTML-like markup.</para>
            // </summary>
            // <param name="text">
            // <para>Unformatted text.</para>
            // </param>
            // <param name="fontName">
            // <para>Name of a system font, or a filename to a TTF file (must contain '/').</para>
            // </param>
            // <param name="fontHeight">
            // <para>Height, in pixels, of the text.</para>
            // </param>
            // <param name="fontFlags">
            // <para>Binary combination of members of the FontFlags</para>
            // <para>enum.</para>
            // </param>
            public static void DrawText(Gosu.Bitmap bitmap, string text, int x, int y, Gosu.Color c, string fontName, uint fontHeight, uint fontFlags = 0)
            {
                if (ReferenceEquals(bitmap, null))
                    throw new global::System.ArgumentNullException("bitmap", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = bitmap.__Instance;
                var __arg1 = text;
                var __arg4 = ReferenceEquals(c, null) ? new Gosu.Color.__Internal() : *(Gosu.Color.__Internal*) c.__Instance;
                var __arg5 = fontName;
                __Internal.DrawText_0(__arg0, __arg1, x, y, __arg4, __arg5, fontHeight, fontFlags);
            }

            // <summary>
            // <para>Creates a bitmap that is filled with a line of formatted text given to the function.</para>
            // <para>The line can contain line breaks and HTML-like markup.</para>
            // </summary>
            // <param name="text">
            // <para>Formatted text.</para>
            // </param>
            // <param name="fontName">
            // <para>Name of a system font, or a filename to a TTF file (must contain '/').</para>
            // </param>
            // <param name="fontHeight">
            // <para>Height of the font in pixels.</para>
            // </param>
            // <param name="fontFlags">
            // <para>Binary combination of members of the FontFlags</para>
            // <para>enum.</para>
            // </param>
            public static Gosu.Bitmap CreateText(string text, string fontName, uint fontHeight, uint fontFlags = 0)
            {
                var __arg0 = text;
                var __arg1 = fontName;
                var __ret = __Internal.CreateText_0(__arg0, __arg1, fontHeight, fontFlags);
                return Gosu.Bitmap.__CreateInstance(__ret);
            }

            // <summary>
            // <para>Creates a bitmap that is filled with the formatted text given to the function.</para>
            // <para>The line can contain line breaks and HTML-like markup.</para>
            // </summary>
            // <param name="text">
            // <para>Formatted text.</para>
            // </param>
            // <param name="fontName">
            // <para>Name of a system font, or a filename to a TTF file (must contain '/').</para>
            // </param>
            // <param name="fontHeight">
            // <para>Height of the font in pixels.</para>
            // </param>
            // <param name="lineSpacing">
            // <para>Spacing between two lines of text in pixels. Can be negative to make</para>
            // <para>text stick together more closely.</para>
            // </param>
            // <param name="width">
            // <para>Width of the bitmap that will be returned. Text</para>
            // <para>will be split into multiple lines to avoid drawing over the right</para>
            // <para>border. When a single word is too long, it will be truncated.</para>
            // </param>
            // <param name="fontFlags">
            // <para>Binary combination of members of the FontFlags</para>
            // <para>enum.</para>
            // </param>
            public static Gosu.Bitmap CreateText(string text, string fontName, uint fontHeight, int lineSpacing, uint width, Gosu.TextAlign align, uint fontFlags = 0)
            {
                var __arg0 = text;
                var __arg1 = fontName;
                var __arg5 = align;
                var __ret = __Internal.CreateText_1(__arg0, __arg1, fontHeight, lineSpacing, width, __arg5, fontFlags);
                return Gosu.Bitmap.__CreateInstance(__ret);
            }

            // <summary>
            // <para>Registers a new HTML-style entity that can subsequently be used</para>
            // <para>with Gosu::Font and Gosu::createText. The name is given without </para>
            // <para>&amp;</para>
            // <para>and ;.</para>
            // </summary>
            public static void RegisterEntity(string name, Gosu.Bitmap replacement)
            {
                var __arg0 = name;
                if (ReferenceEquals(replacement, null))
                    throw new global::System.ArgumentNullException("replacement", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = replacement.__Instance;
                __Internal.RegisterEntity_0(__arg0, __arg1);
            }
        }
    }

    namespace Gosu
    {
        public unsafe partial class Math
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?trunc@Gosu@@YAJN@Z")]
                internal static extern int Trunc_0(double value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?round@Gosu@@YAJN@Z")]
                internal static extern int Round_0(double value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?random@Gosu@@YANNN@Z")]
                internal static extern double Random_0(double min, double max);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?gosuToRadians@Gosu@@YANN@Z")]
                internal static extern double GosuToRadians_0(double angle);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?radiansToGosu@Gosu@@YANN@Z")]
                internal static extern double RadiansToGosu_0(double angle);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?degreesToRadians@Gosu@@YANN@Z")]
                internal static extern double DegreesToRadians_0(double angle);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?radiansToDegrees@Gosu@@YANN@Z")]
                internal static extern double RadiansToDegrees_0(double angle);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?offsetX@Gosu@@YANNN@Z")]
                internal static extern double OffsetX_0(double angle, double radius);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?offsetY@Gosu@@YANNN@Z")]
                internal static extern double OffsetY_0(double angle, double radius);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?angle@Gosu@@YANNNNNN@Z")]
                internal static extern double Angle_0(double fromX, double fromY, double toX, double toY, double def);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?angleDiff@Gosu@@YANNN@Z")]
                internal static extern double AngleDiff_0(double angle1, double angle2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?normalizeAngle@Gosu@@YANN@Z")]
                internal static extern double NormalizeAngle_0(double angle);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?wrap@Gosu@@YAHHHH@Z")]
                internal static extern int Wrap_0(int value, int min, int max);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?wrap@Gosu@@YAMMMM@Z")]
                internal static extern float Wrap_1(float value, float min, float max);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?wrap@Gosu@@YANNNN@Z")]
                internal static extern double Wrap_2(double value, double min, double max);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?distanceSqr@Gosu@@YANNNNN@Z")]
                internal static extern double DistanceSqr_0(double x1, double y1, double x2, double y2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?distance@Gosu@@YANNNNN@Z")]
                internal static extern double Distance_0(double x1, double y1, double x2, double y2);
            }

            // <summary>
            // <para>Truncates the fractional part of a real value. Equivalent to</para>
            // <para>static_cast</para>
            // <para>&lt;long</para>
            // <para>&gt;.</para>
            // </summary>
            public static int Trunc(double value)
            {
                var __ret = __Internal.Trunc_0(value);
                return __ret;
            }

            // <summary>
            // <para>Rounds a real value towards the next integer.</para>
            // </summary>
            public static int Round(double value)
            {
                var __ret = __Internal.Round_0(value);
                return __ret;
            }

            // <summary>
            // <para>Returns a real value between min (inclusive) and max (exclusive).</para>
            // <para>Uses std::rand, so you should call std::srand before using it.</para>
            // </summary>
            public static double Random(double min, double max)
            {
                var __ret = __Internal.Random_0(min, max);
                return __ret;
            }

            // <summary>
            // <para>Translates between Gosu's angle system (where 0 is at the top)</para>
            // <para>and radians (where 0 is at the right).</para>
            // </summary>
            public static double GosuToRadians(double angle)
            {
                var __ret = __Internal.GosuToRadians_0(angle);
                return __ret;
            }

            // <summary>
            // <para>Translates between Gosu's angle system (where 0 is at the top)</para>
            // <para>and radians (where 0 is at the right).</para>
            // </summary>
            public static double RadiansToGosu(double angle)
            {
                var __ret = __Internal.RadiansToGosu_0(angle);
                return __ret;
            }

            // <summary>
            // <para>Translates between degrees (used by Gosu) and radians, i.e. it</para>
            // <para>does not change the 'origin' of the angle system.</para>
            // </summary>
            public static double DegreesToRadians(double angle)
            {
                var __ret = __Internal.DegreesToRadians_0(angle);
                return __ret;
            }

            // <summary>
            // <para>Translates between degrees (used by Gosu) and radians, i.e. it</para>
            // <para>does not change the 'origin' of the angle system.</para>
            // </summary>
            public static double RadiansToDegrees(double angle)
            {
                var __ret = __Internal.RadiansToDegrees_0(angle);
                return __ret;
            }

            // <summary>
            // <para>Returns the horizontal distance between the origin and the point to</para>
            // <para>which you would get if you moved radius pixels in the direction</para>
            // <para>specified by angle.</para>
            // </summary>
            // <param name="angle">
            // <para>Angle in degrees where 0.0 means upwards.</para>
            // </param>
            public static double OffsetX(double angle, double radius)
            {
                var __ret = __Internal.OffsetX_0(angle, radius);
                return __ret;
            }

            // <summary>
            // <para>Returns the vertical distance between the origin and the point to</para>
            // <para>which you would get if you moved radius pixels in the direction</para>
            // <para>specified by angle.</para>
            // </summary>
            // <param name="angle">
            // <para>Angle in degrees where 0.0 means upwards.</para>
            // </param>
            public static double OffsetY(double angle, double radius)
            {
                var __ret = __Internal.OffsetY_0(angle, radius);
                return __ret;
            }

            // <summary>
            // <para>Returns the angle from point 1 to point 2 in degrees, where 0.0 means</para>
            // <para>upwards. Returns def if both points are equal.</para>
            // </summary>
            public static double Angle(double fromX, double fromY, double toX, double toY, double def = 0)
            {
                var __ret = __Internal.Angle_0(fromX, fromY, toX, toY, def);
                return __ret;
            }

            // <summary>
            // <para>Returns the smallest angle that can be added to angle1 to get to</para>
            // <para>angle2 (can be negative if counter-clockwise movement is shorter).</para>
            // </summary>
            public static double AngleDiff(double angle1, double angle2)
            {
                var __ret = __Internal.AngleDiff_0(angle1, angle2);
                return __ret;
            }

            // <summary>
            // <para>Normalizes an angle to fit into the range [0; 360[.</para>
            // </summary>
            public static double NormalizeAngle(double angle)
            {
                var __ret = __Internal.NormalizeAngle_0(angle);
                return __ret;
            }

            // <summary>
            // <para>Returns (value-min) % (max-min) + min, where % always has a positive</para>
            // <para>result for max &gt; min. The results are undefined for max </para>
            // <para>&lt;</para>
            // <para>= min.</para>
            // <para>Note: This means that max is exclusive.</para>
            // </summary>
            public static int Wrap(int value, int min, int max)
            {
                var __ret = __Internal.Wrap_0(value, min, max);
                return __ret;
            }

            // <summary>
            // <para>Returns (value-min) % (max-min) + min, where % always has a positive</para>
            // <para>result for max &gt; min. The results are undefined for max </para>
            // <para>&lt;</para>
            // <para>= min.</para>
            // <para>Note: This means that max is exclusive.</para>
            // </summary>
            public static float Wrap(float value, float min, float max)
            {
                var __ret = __Internal.Wrap_1(value, min, max);
                return __ret;
            }

            // <summary>
            // <para>Returns (value-min) % (max-min) + min, where % always has a positive</para>
            // <para>result for max &gt; min. The results are undefined for max </para>
            // <para>&lt;</para>
            // <para>= min.</para>
            // <para>Note: This means that max is exclusive.</para>
            // </summary>
            public static double Wrap(double value, double min, double max)
            {
                var __ret = __Internal.Wrap_2(value, min, max);
                return __ret;
            }

            // <summary>
            // <para>Returns the square of the distance between two points.</para>
            // </summary>
            public static double DistanceSqr(double x1, double y1, double x2, double y2)
            {
                var __ret = __Internal.DistanceSqr_0(x1, y1, x2, y2);
                return __ret;
            }

            // <summary>
            // <para>Returns the distance between two points.</para>
            // </summary>
            public static double Distance(double x1, double y1, double x2, double y2)
            {
                var __ret = __Internal.Distance_0(x1, y1, x2, y2);
                return __ret;
            }

            // <summary>
            // <para>Pi.</para>
            // </summary>
            public static double Pi
            {
                get
                {
                    var __ptr = (double*)CppSharp.SymbolResolver.ResolveSymbol("Gosu.dll", "?pi@Gosu@@3NB");
                    return *__ptr;
                }
            }
        }
    }

    namespace Gosu
    {
        // <summary>
        // <para>TextInput instances are invisible objects that build a text string from input,</para>
        // <para>using the current operating system's keyboard layout.</para>
        // <para>At its most basic form, you only need to create a new TextInput instance and</para>
        // <para>pass it to your window via setTextInput. Until you call this function again,</para>
        // <para>passing 0, the TextInput object will build a text that can be accessed via</para>
        // <para>TextInput::text().</para>
        // <para>A TextInput object is purely abstract, though; drawing the input field is left</para>
        // <para>to the user. As with most of Gosu, how this is handled is completely left open.</para>
        // <para>TextInput only aims to provide enough code for your own GUIs to build upon.</para>
        // </summary>
        public unsafe partial class TextInput : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr vfptr_TextInput;

                [FieldOffset(4)]
                internal global::Std.UniquePtr.__Internal pimpl;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0TextInput@Gosu@@QAE@XZ")]
                internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?feedSDLEvent@TextInput@Gosu@@QAE_NPAX@Z")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool FeedSDLEvent_0(global::System.IntPtr instance, global::System.IntPtr @event);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?text@TextInput@Gosu@@QBEPBDXZ")]
                internal static extern global::System.IntPtr Text_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setText@TextInput@Gosu@@QAEXPBD@Z")]
                internal static extern void SetText_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string text);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?caretPos@TextInput@Gosu@@QBEIXZ")]
                internal static extern uint CaretPos_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setCaretPos@TextInput@Gosu@@QAEXI@Z")]
                internal static extern void SetCaretPos_0(global::System.IntPtr instance, uint pos);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?selectionStart@TextInput@Gosu@@QBEIXZ")]
                internal static extern uint SelectionStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setSelectionStart@TextInput@Gosu@@QAEXI@Z")]
                internal static extern void SetSelectionStart_0(global::System.IntPtr instance, uint pos);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TextInput> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TextInput>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static TextInput __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new TextInput(native.ToPointer(), skipVTables);
            }

            public static TextInput __CreateInstance(TextInput.__Internal native, bool skipVTables = false)
            {
                return new TextInput(native, skipVTables);
            }

            private static void* __CopyValue(TextInput.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(8);
                *(TextInput.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private TextInput(TextInput.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TextInput(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                if (skipVTables)
                    __OriginalVTables = new void*[] { ((__Internal*) native)->vfptr_TextInput.ToPointer() };
                else
                    SetupVTables(true);
            }

            public TextInput()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor_2((__Instance + __PointerAdjustment));
                SetupVTables(GetType().FullName == "GosuNET.Gosu.TextInput");
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                Gosu.TextInput __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                ((__Internal*) __Instance)->vfptr_TextInput = new global::System.IntPtr(__OriginalVTables[0]);
                if (disposing)
                {
                    var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                    var ___dtor_0Delegate = (Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr_int));
                    ___dtor_0Delegate((__Instance + __PointerAdjustment), 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool FeedSDLEvent(global::System.IntPtr @event)
            {
                var __arg0 = @event;
                var __ret = __Internal.FeedSDLEvent_0((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            // <summary>
            // <para>Overridable filter that is applied to all new text that is entered.</para>
            // <para>Allows for context-sensitive filtering/extending/... of the text.</para>
            // <para>The text will be inserted at caretPos afterwards.</para>
            // </summary>
            public virtual string Filter(string text)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
                var ___Filter_0Delegate = (Delegates.Func_string_IntPtr_string) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_string_IntPtr_string));
                var __arg0 = text;
                var __ret = ___Filter_0Delegate((__Instance + __PointerAdjustment), __arg0);
                return Marshal.PtrToStringAnsi(__ret);
            }

            public string Text
            {
                get
                {
                    var __ret = __Internal.Text_0((__Instance + __PointerAdjustment));
                    return Marshal.PtrToStringAnsi(__ret);
                }

                set
                {
                    var __arg0 = value;
                    __Internal.SetText_0((__Instance + __PointerAdjustment), __arg0);
                }
            }

            // <summary>
            // <para>Position of the caret as the index of the character that it's left to.</para>
            // </summary>
            // <remarks>
            // <para>Sets the caret position as returned by caretPos.</para>
            // <para>You usually also want to use setSelectionStart.</para>
            // </remarks>
            public uint CaretPos
            {
                get
                {
                    var __ret = __Internal.CaretPos_0((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetCaretPos_0((__Instance + __PointerAdjustment), value);
                }
            }

            // <summary>
            // <para>If there is a selection, the selectionStart() member yields its beginning,</para>
            // <para>using the same indexing scheme as caretPos. If there is no selection,</para>
            // <para>selectionStart() is equal to caretPos().</para>
            // </summary>
            // <remarks>
            // <para>Sets the start of the selection as returned by selectionStart.</para>
            // </remarks>
            public uint SelectionStart
            {
                get
                {
                    var __ret = __Internal.SelectionStart_0((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetSelectionStart_0((__Instance + __PointerAdjustment), value);
                }
            }

            #region Virtual table interop

            // virtual ~TextInput()
            private static Delegates.Action_IntPtr_int _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance, int delete)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TextInput) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Dispose(true);
            }

            // char* filter(const char* text) const
            private static Delegates.Func_string_IntPtr_string _Filter_0DelegateInstance;

            private static global::System.IntPtr _Filter_0DelegateHook(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string text)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TextInput) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Filter(text);
                return Marshal.StringToHGlobalAnsi(__ret);
            }

            private static void*[] __ManagedVTables;
            private static void*[] __ManagedVTablesDtorOnly;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                var native = (__Internal*) __Instance.ToPointer();

                __OriginalVTables = new void*[] { ((__Internal*) native)->vfptr_TextInput.ToPointer() };

                if (_Thunks == null)
                {
                    _Thunks = new void*[2];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _Filter_0DelegateInstance += _Filter_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Filter_0DelegateInstance).ToPointer();
                }

                if (destructorOnly)
                {
                    if (__ManagedVTablesDtorOnly == null)
                    {
                        __ManagedVTablesDtorOnly = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                        __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                        *(void**)(vfptr0 + 0) = _Thunks[0];
                        *(void**)(vfptr0 + 4) = *(void**)(native->vfptr_TextInput + 4);
                    }

                    native->vfptr_TextInput = new IntPtr(__ManagedVTablesDtorOnly[0]);
                }
                else
                {
                    if (__ManagedVTables == null)
                    {
                        __ManagedVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                        __ManagedVTables[0] = vfptr0.ToPointer();
                        *(void**)(vfptr0 + 0) = _Thunks[0];
                        *(void**)(vfptr0 + 4) = _Thunks[1];
                    }

                    native->vfptr_TextInput = new IntPtr(__ManagedVTables[0]);
                }
            }

            #endregion
        }
    }

    namespace Gosu
    {
        // <summary>
        // <para>Convenient all-in-one class that serves as the foundation of a standard</para>
        // <para>Gosu application. Manages initialization of all of Gosu's core components</para>
        // <para>and provides timing functionality.</para>
        // <para>Note that you should really only use one instance of this class at the same time.</para>
        // <para>This may or may not change later.</para>
        // </summary>
        public unsafe partial class Window : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr vfptr_Window;

                [FieldOffset(4)]
                internal global::Std.UniquePtr.__Internal pimpl;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Window@Gosu@@QAE@II_NN@Z")]
                internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, uint width, uint height, bool fullscreen, double updateInterval);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setCaption@Window@Gosu@@QAEXPBD@Z")]
                internal static extern void SetCaption_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string caption);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?close@Window@Gosu@@QAEXXZ")]
                internal static extern void Close_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?updateInterval@Window@Gosu@@QBENXZ")]
                internal static extern double UpdateInterval_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?graphics@Window@Gosu@@QBEABVGraphics@2@XZ")]
                internal static extern global::System.IntPtr Graphics_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?graphics@Window@Gosu@@QAEAAVGraphics@2@XZ")]
                internal static extern global::System.IntPtr graphics_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?input@Window@Gosu@@QBEABVInput@2@XZ")]
                internal static extern global::System.IntPtr Input_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?input@Window@Gosu@@QAEAAVInput@2@XZ")]
                internal static extern global::System.IntPtr input_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Window> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Window>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static Window __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new Window(native.ToPointer(), skipVTables);
            }

            public static Window __CreateInstance(Window.__Internal native, bool skipVTables = false)
            {
                return new Window(native, skipVTables);
            }

            private static void* __CopyValue(Window.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(8);
                *(Window.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Window(Window.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Window(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                if (skipVTables)
                    __OriginalVTables = new void*[] { ((__Internal*) native)->vfptr_Window.ToPointer() };
                else
                    SetupVTables(true);
            }

            // <summary>
            // <para>Constructs a Window.</para>
            // </summary>
            // <param name="width">
            // <para>Width of the window in points; that is, pixels on a normal display, and 'virtual pixels' on a</para>
            // <para>high-resolution display.</para>
            // </param>
            // <param name="height">
            // <para>See width.</para>
            // </param>
            // <param name="updateInterval">
            // <para>Interval in milliseconds between two calls</para>
            // <para>to the update member function.</para>
            // </param>
            public Window(uint width, uint height, bool fullscreen = false, double updateInterval = 16.666665999999999)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor_2((__Instance + __PointerAdjustment), width, height, fullscreen, updateInterval);
                SetupVTables(GetType().FullName == "GosuNET.Gosu.Window");
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                Gosu.Window __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                ((__Internal*) __Instance)->vfptr_Window = new global::System.IntPtr(__OriginalVTables[0]);
                if (disposing)
                {
                    var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                    var ___dtor_0Delegate = (Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr_int));
                    ___dtor_0Delegate((__Instance + __PointerAdjustment), 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public void SetCaption(string caption)
            {
                var __arg0 = caption;
                __Internal.SetCaption_0((__Instance + __PointerAdjustment), __arg0);
            }

            // <summary>
            // <para>Enters a modal loop where the Window is visible on screen and</para>
            // <para>receives calls to draw, update etc.</para>
            // </summary>
            public virtual void Show()
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
                var ___Show_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
                ___Show_0Delegate((__Instance + __PointerAdjustment));
            }

            // <summary>
            // <para>Closes the window if it is currently shown.</para>
            // </summary>
            public void Close()
            {
                __Internal.Close_0((__Instance + __PointerAdjustment));
            }

            // <summary>
            // <para>Called every updateInterval milliseconds while the window is being</para>
            // <para>shown. Your application's main game logic goes here.</para>
            // </summary>
            public virtual void Update()
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 4);
                var ___Update_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
                ___Update_0Delegate((__Instance + __PointerAdjustment));
            }

            // <summary>
            // <para>Called after every update and when the OS wants the window to</para>
            // <para>repaint itself. Your application's rendering code goes here.</para>
            // </summary>
            public virtual void Draw()
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 4);
                var ___Draw_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
                ___Draw_0Delegate((__Instance + __PointerAdjustment));
            }

            // <summary>
            // <para>This function is called when the window loses focus on some platforms.</para>
            // <para>Most importantly, it is called on the iPhone or iPad when the user</para>
            // <para>locks the screen.</para>
            // </summary>
            public virtual void LoseFocus()
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 4);
                var ___LoseFocus_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
                ___LoseFocus_0Delegate((__Instance + __PointerAdjustment));
            }

            // <summary>
            // <para>This function is called when the operating system's memory is low.</para>
            // <para>So far, it is only called in iOS applications.</para>
            // </summary>
            public virtual void ReleaseMemory()
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 4);
                var ___ReleaseMemory_0Delegate = (Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr));
                ___ReleaseMemory_0Delegate((__Instance + __PointerAdjustment));
            }

            // <summary>
            // <para>Called before update when the user pressed a button while the</para>
            // <para>window had the focus.</para>
            // </summary>
            public virtual void ButtonDown(Gosu.Button _0)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 9 * 4);
                var ___ButtonDown_0Delegate = (Delegates.Action_IntPtr_Gosu_Button___Internal) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr_Gosu_Button___Internal));
                var __arg0 = ReferenceEquals(_0, null) ? new Gosu.Button.__Internal() : *(Gosu.Button.__Internal*) _0.__Instance;
                ___ButtonDown_0Delegate((__Instance + __PointerAdjustment), __arg0);
            }

            // <summary>
            // <para>Same as buttonDown. Called then the user released a button.</para>
            // </summary>
            public virtual void ButtonUp(Gosu.Button _0)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 10 * 4);
                var ___ButtonUp_0Delegate = (Delegates.Action_IntPtr_Gosu_Button___Internal) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr_Gosu_Button___Internal));
                var __arg0 = ReferenceEquals(_0, null) ? new Gosu.Button.__Internal() : *(Gosu.Button.__Internal*) _0.__Instance;
                ___ButtonUp_0Delegate((__Instance + __PointerAdjustment), __arg0);
            }

            public virtual void TouchBegan(Gosu.Touch touch)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 11 * 4);
                var ___TouchBegan_0Delegate = (Delegates.Action_IntPtr_Gosu_Touch___Internal) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr_Gosu_Touch___Internal));
                var __arg0 = ReferenceEquals(touch, null) ? new Gosu.Touch.__Internal() : *(Gosu.Touch.__Internal*) touch.__Instance;
                ___TouchBegan_0Delegate((__Instance + __PointerAdjustment), __arg0);
            }

            public virtual void TouchMoved(Gosu.Touch touch)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 12 * 4);
                var ___TouchMoved_0Delegate = (Delegates.Action_IntPtr_Gosu_Touch___Internal) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr_Gosu_Touch___Internal));
                var __arg0 = ReferenceEquals(touch, null) ? new Gosu.Touch.__Internal() : *(Gosu.Touch.__Internal*) touch.__Instance;
                ___TouchMoved_0Delegate((__Instance + __PointerAdjustment), __arg0);
            }

            public virtual void TouchEnded(Gosu.Touch touch)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 13 * 4);
                var ___TouchEnded_0Delegate = (Delegates.Action_IntPtr_Gosu_Touch___Internal) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr_Gosu_Touch___Internal));
                var __arg0 = ReferenceEquals(touch, null) ? new Gosu.Touch.__Internal() : *(Gosu.Touch.__Internal*) touch.__Instance;
                ___TouchEnded_0Delegate((__Instance + __PointerAdjustment), __arg0);
            }

            public virtual void TouchCancelled(Gosu.Touch touch)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 14 * 4);
                var ___TouchCancelled_0Delegate = (Delegates.Action_IntPtr_Gosu_Touch___Internal) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Action_IntPtr_Gosu_Touch___Internal));
                var __arg0 = ReferenceEquals(touch, null) ? new Gosu.Touch.__Internal() : *(Gosu.Touch.__Internal*) touch.__Instance;
                ___TouchCancelled_0Delegate((__Instance + __PointerAdjustment), __arg0);
            }

            public double UpdateInterval
            {
                get
                {
                    var __ret = __Internal.UpdateInterval_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            // <summary>
            // <para>Performs a single mainloop step.</para>
            // <para>This method is only useful if you want to integrate Gosu with</para>
            // <para>another library that has its own main loop.</para>
            // <para>This method implicitly shows the window if it was hidden before, and</para>
            // <para>returns false when the window has been closed.</para>
            // <para>If you discard the return value and keep calling tick(), the window will be shown again,</para>
            // <para>or keep being shown.</para>
            // </summary>
            public virtual bool Tick
            {
                get
                {
                    var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
                    var ___Tick_0Delegate = (Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr));
                    var __ret = ___Tick_0Delegate((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            // <summary>
            // <para>Gives the game a chance to say no to being redrawn.</para>
            // <para>This is not a definitive answer. The operating system can still force</para>
            // <para>the window to redraw itself.</para>
            // <para>By default, the window is redrawn all the time.</para>
            // </summary>
            public virtual bool NeedsRedraw
            {
                get
                {
                    var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 4);
                    var ___NeedsRedraw_0Delegate = (Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr));
                    var __ret = ___NeedsRedraw_0Delegate((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            // <summary>
            // <para>If this function returns true, the system arrow cursor is drawn while</para>
            // <para>over the window.</para>
            // </summary>
            public virtual bool NeedsCursor
            {
                get
                {
                    var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 4);
                    var ___NeedsCursor_0Delegate = (Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(Delegates.Func_bool_IntPtr));
                    var __ret = ___NeedsCursor_0Delegate((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public Gosu.Graphics Graphics
            {
                get
                {
                    var __ret = __Internal.Graphics_0((__Instance + __PointerAdjustment));
                    Gosu.Graphics __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (Gosu.Graphics.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (Gosu.Graphics) Gosu.Graphics.NativeToManagedMap[__ret];
                    else __result0 = Gosu.Graphics.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public Gosu.Graphics graphics
            {
                get
                {
                    var __ret = __Internal.graphics_0((__Instance + __PointerAdjustment));
                    Gosu.Graphics __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (Gosu.Graphics.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (Gosu.Graphics) Gosu.Graphics.NativeToManagedMap[__ret];
                    else __result0 = Gosu.Graphics.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public Gosu.Input Input
            {
                get
                {
                    var __ret = __Internal.Input_0((__Instance + __PointerAdjustment));
                    Gosu.Input __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (Gosu.Input.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (Gosu.Input) Gosu.Input.NativeToManagedMap[__ret];
                    else __result0 = Gosu.Input.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public Gosu.Input input
            {
                get
                {
                    var __ret = __Internal.input_0((__Instance + __PointerAdjustment));
                    Gosu.Input __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (Gosu.Input.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (Gosu.Input) Gosu.Input.NativeToManagedMap[__ret];
                    else __result0 = Gosu.Input.__CreateInstance(__ret);
                    return __result0;
                }
            }

            #region Virtual table interop

            // virtual ~Window()
            private static Delegates.Action_IntPtr_int _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance, int delete)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (Window) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Dispose(true);
            }

            // void show()
            private static Delegates.Action_IntPtr _Show_0DelegateInstance;

            private static void _Show_0DelegateHook(global::System.IntPtr instance)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (Window) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Show();
            }

            // bool tick()
            private static Delegates.Func_bool_IntPtr _Tick_0DelegateInstance;

            private static bool _Tick_0DelegateHook(global::System.IntPtr instance)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (Window) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Tick;
                return __ret;
            }

            // void update()
            private static Delegates.Action_IntPtr _Update_0DelegateInstance;

            private static void _Update_0DelegateHook(global::System.IntPtr instance)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (Window) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Update();
            }

            // void draw()
            private static Delegates.Action_IntPtr _Draw_0DelegateInstance;

            private static void _Draw_0DelegateHook(global::System.IntPtr instance)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (Window) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Draw();
            }

            // bool needsRedraw() const
            private static Delegates.Func_bool_IntPtr _NeedsRedraw_0DelegateInstance;

            private static bool _NeedsRedraw_0DelegateHook(global::System.IntPtr instance)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (Window) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.NeedsRedraw;
                return __ret;
            }

            // bool needsCursor() const
            private static Delegates.Func_bool_IntPtr _NeedsCursor_0DelegateInstance;

            private static bool _NeedsCursor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (Window) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.NeedsCursor;
                return __ret;
            }

            // void loseFocus()
            private static Delegates.Action_IntPtr _LoseFocus_0DelegateInstance;

            private static void _LoseFocus_0DelegateHook(global::System.IntPtr instance)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (Window) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.LoseFocus();
            }

            // void releaseMemory()
            private static Delegates.Action_IntPtr _ReleaseMemory_0DelegateInstance;

            private static void _ReleaseMemory_0DelegateHook(global::System.IntPtr instance)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (Window) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.ReleaseMemory();
            }

            // void buttonDown(Gosu::Button)
            private static Delegates.Action_IntPtr_Gosu_Button___Internal _ButtonDown_0DelegateInstance;

            private static void _ButtonDown_0DelegateHook(global::System.IntPtr instance, Gosu.Button.__Internal _0)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (Window) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.ButtonDown(Gosu.Button.__CreateInstance(_0));
            }

            // void buttonUp(Gosu::Button)
            private static Delegates.Action_IntPtr_Gosu_Button___Internal _ButtonUp_0DelegateInstance;

            private static void _ButtonUp_0DelegateHook(global::System.IntPtr instance, Gosu.Button.__Internal _0)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (Window) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.ButtonUp(Gosu.Button.__CreateInstance(_0));
            }

            // void touchBegan(Touch touch)
            private static Delegates.Action_IntPtr_Gosu_Touch___Internal _TouchBegan_0DelegateInstance;

            private static void _TouchBegan_0DelegateHook(global::System.IntPtr instance, Gosu.Touch.__Internal touch)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (Window) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.TouchBegan(Gosu.Touch.__CreateInstance(touch));
            }

            // void touchMoved(Touch touch)
            private static Delegates.Action_IntPtr_Gosu_Touch___Internal _TouchMoved_0DelegateInstance;

            private static void _TouchMoved_0DelegateHook(global::System.IntPtr instance, Gosu.Touch.__Internal touch)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (Window) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.TouchMoved(Gosu.Touch.__CreateInstance(touch));
            }

            // void touchEnded(Touch touch)
            private static Delegates.Action_IntPtr_Gosu_Touch___Internal _TouchEnded_0DelegateInstance;

            private static void _TouchEnded_0DelegateHook(global::System.IntPtr instance, Gosu.Touch.__Internal touch)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (Window) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.TouchEnded(Gosu.Touch.__CreateInstance(touch));
            }

            // void touchCancelled(Touch touch)
            private static Delegates.Action_IntPtr_Gosu_Touch___Internal _TouchCancelled_0DelegateInstance;

            private static void _TouchCancelled_0DelegateHook(global::System.IntPtr instance, Gosu.Touch.__Internal touch)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (Window) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.TouchCancelled(Gosu.Touch.__CreateInstance(touch));
            }

            private static void*[] __ManagedVTables;
            private static void*[] __ManagedVTablesDtorOnly;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                var native = (__Internal*) __Instance.ToPointer();

                __OriginalVTables = new void*[] { ((__Internal*) native)->vfptr_Window.ToPointer() };

                if (_Thunks == null)
                {
                    _Thunks = new void*[15];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _Show_0DelegateInstance += _Show_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Show_0DelegateInstance).ToPointer();
                    _Tick_0DelegateInstance += _Tick_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Tick_0DelegateInstance).ToPointer();
                    _Update_0DelegateInstance += _Update_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_Update_0DelegateInstance).ToPointer();
                    _Draw_0DelegateInstance += _Draw_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_Draw_0DelegateInstance).ToPointer();
                    _NeedsRedraw_0DelegateInstance += _NeedsRedraw_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_NeedsRedraw_0DelegateInstance).ToPointer();
                    _NeedsCursor_0DelegateInstance += _NeedsCursor_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_NeedsCursor_0DelegateInstance).ToPointer();
                    _LoseFocus_0DelegateInstance += _LoseFocus_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_LoseFocus_0DelegateInstance).ToPointer();
                    _ReleaseMemory_0DelegateInstance += _ReleaseMemory_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_ReleaseMemory_0DelegateInstance).ToPointer();
                    _ButtonDown_0DelegateInstance += _ButtonDown_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_ButtonDown_0DelegateInstance).ToPointer();
                    _ButtonUp_0DelegateInstance += _ButtonUp_0DelegateHook;
                    _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_ButtonUp_0DelegateInstance).ToPointer();
                    _TouchBegan_0DelegateInstance += _TouchBegan_0DelegateHook;
                    _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_TouchBegan_0DelegateInstance).ToPointer();
                    _TouchMoved_0DelegateInstance += _TouchMoved_0DelegateHook;
                    _Thunks[12] = Marshal.GetFunctionPointerForDelegate(_TouchMoved_0DelegateInstance).ToPointer();
                    _TouchEnded_0DelegateInstance += _TouchEnded_0DelegateHook;
                    _Thunks[13] = Marshal.GetFunctionPointerForDelegate(_TouchEnded_0DelegateInstance).ToPointer();
                    _TouchCancelled_0DelegateInstance += _TouchCancelled_0DelegateHook;
                    _Thunks[14] = Marshal.GetFunctionPointerForDelegate(_TouchCancelled_0DelegateInstance).ToPointer();
                }

                if (destructorOnly)
                {
                    if (__ManagedVTablesDtorOnly == null)
                    {
                        __ManagedVTablesDtorOnly = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(15 * 4);
                        __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                        *(void**)(vfptr0 + 0) = _Thunks[0];
                        *(void**)(vfptr0 + 4) = *(void**)(native->vfptr_Window + 4);
                        *(void**)(vfptr0 + 8) = *(void**)(native->vfptr_Window + 8);
                        *(void**)(vfptr0 + 12) = *(void**)(native->vfptr_Window + 12);
                        *(void**)(vfptr0 + 16) = *(void**)(native->vfptr_Window + 16);
                        *(void**)(vfptr0 + 20) = *(void**)(native->vfptr_Window + 20);
                        *(void**)(vfptr0 + 24) = *(void**)(native->vfptr_Window + 24);
                        *(void**)(vfptr0 + 28) = *(void**)(native->vfptr_Window + 28);
                        *(void**)(vfptr0 + 32) = *(void**)(native->vfptr_Window + 32);
                        *(void**)(vfptr0 + 36) = *(void**)(native->vfptr_Window + 36);
                        *(void**)(vfptr0 + 40) = *(void**)(native->vfptr_Window + 40);
                        *(void**)(vfptr0 + 44) = *(void**)(native->vfptr_Window + 44);
                        *(void**)(vfptr0 + 48) = *(void**)(native->vfptr_Window + 48);
                        *(void**)(vfptr0 + 52) = *(void**)(native->vfptr_Window + 52);
                        *(void**)(vfptr0 + 56) = *(void**)(native->vfptr_Window + 56);
                    }

                    native->vfptr_Window = new IntPtr(__ManagedVTablesDtorOnly[0]);
                }
                else
                {
                    if (__ManagedVTables == null)
                    {
                        __ManagedVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(15 * 4);
                        __ManagedVTables[0] = vfptr0.ToPointer();
                        *(void**)(vfptr0 + 0) = _Thunks[0];
                        *(void**)(vfptr0 + 4) = _Thunks[1];
                        *(void**)(vfptr0 + 8) = _Thunks[2];
                        *(void**)(vfptr0 + 12) = _Thunks[3];
                        *(void**)(vfptr0 + 16) = _Thunks[4];
                        *(void**)(vfptr0 + 20) = _Thunks[5];
                        *(void**)(vfptr0 + 24) = _Thunks[6];
                        *(void**)(vfptr0 + 28) = _Thunks[7];
                        *(void**)(vfptr0 + 32) = _Thunks[8];
                        *(void**)(vfptr0 + 36) = _Thunks[9];
                        *(void**)(vfptr0 + 40) = _Thunks[10];
                        *(void**)(vfptr0 + 44) = _Thunks[11];
                        *(void**)(vfptr0 + 48) = _Thunks[12];
                        *(void**)(vfptr0 + 52) = _Thunks[13];
                        *(void**)(vfptr0 + 56) = _Thunks[14];
                    }

                    native->vfptr_Window = new IntPtr(__ManagedVTables[0]);
                }
            }

            #endregion
        }

        public unsafe partial class Window
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?screenWidth@Gosu@@YAIXZ")]
                internal static extern uint ScreenWidth_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?screenHeight@Gosu@@YAIXZ")]
                internal static extern uint ScreenHeight_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?availableWidth@Gosu@@YAIXZ")]
                internal static extern uint AvailableWidth_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?availableHeight@Gosu@@YAIXZ")]
                internal static extern uint AvailableHeight_0();
            }

            // <summary>
            // <para>Returns the width (in pixels) of the user's primary screen.</para>
            // </summary>
            public static uint ScreenWidth()
            {
                var __ret = __Internal.ScreenWidth_0();
                return __ret;
            }

            // <summary>
            // <para>Returns the height (in pixels) of the user's primary screen.</para>
            // </summary>
            public static uint ScreenHeight()
            {
                var __ret = __Internal.ScreenHeight_0();
                return __ret;
            }

            // <summary>
            // <para>Returns the maximum width (in 'points') that is available for a non-fullscreen Window.</para>
            // <para>All windows larger than this size will automatically be shrunk to fit.</para>
            // </summary>
            public static uint AvailableWidth()
            {
                var __ret = __Internal.AvailableWidth_0();
                return __ret;
            }

            // <summary>
            // <para>Returns the maximum height (in 'points') that is available for a non-fullscreen Window.</para>
            // <para>All windows larger than this size will automatically be shrunk to fit.</para>
            // </summary>
            public static uint AvailableHeight()
            {
                var __ret = __Internal.AvailableHeight_0();
                return __ret;
            }
        }
    }

    namespace Gosu
    {
        // <summary>
        // <para>List of button ids that can be used with Gosu::Input.</para>
        // <para>This enumeration contains ids for keyboard keys (kb*),</para>
        // <para>mouse buttons and mouse wheel (ms*) and gamepad buttons (gp*).</para>
        // </summary>
        public enum ButtonName
        {
            KbRangeBegin = 0,
            KbEscape = 41,
            KbF1 = 58,
            KbF2 = 59,
            KbF3 = 60,
            KbF4 = 61,
            KbF5 = 62,
            KbF6 = 63,
            KbF7 = 64,
            KbF8 = 65,
            KbF9 = 66,
            KbF10 = 67,
            KbF11 = 68,
            KbF12 = 69,
            Kb0 = 39,
            Kb1 = 30,
            Kb2 = 31,
            Kb3 = 32,
            Kb4 = 33,
            Kb5 = 34,
            Kb6 = 35,
            Kb7 = 36,
            Kb8 = 37,
            Kb9 = 38,
            KbTab = 43,
            KbReturn = 40,
            KbSpace = 44,
            KbLeftShift = 225,
            KbRightShift = 229,
            KbLeftControl = 224,
            KbRightControl = 228,
            KbLeftAlt = 226,
            KbRightAlt = 230,
            KbLeftMeta = 227,
            KbRightMeta = 231,
            KbBackspace = 42,
            KbLeft = 80,
            KbRight = 79,
            KbUp = 82,
            KbDown = 81,
            KbHome = 74,
            KbEnd = 77,
            KbInsert = 73,
            KbDelete = 76,
            KbPageUp = 75,
            KbPageDown = 78,
            KbEnter = 88,
            KbBacktick = 53,
            KbMinus = 45,
            KbEqual = 46,
            KbBracketLeft = 47,
            KbBracketRight = 48,
            KbBackslash = 49,
            KbSemicolon = 51,
            KbApostrophe = 52,
            KbComma = 54,
            KbPeriod = 55,
            KbSlash = 49,
            KbA = 4,
            KbB = 5,
            KbC = 6,
            KbD = 7,
            KbE = 8,
            KbF = 9,
            KbG = 10,
            KbH = 11,
            KbI = 12,
            KbJ = 13,
            KbK = 14,
            KbL = 15,
            KbM = 16,
            KbN = 17,
            KbO = 18,
            KbP = 19,
            KbQ = 20,
            KbR = 21,
            KbS = 22,
            KbT = 23,
            KbU = 24,
            KbV = 25,
            KbW = 26,
            KbX = 27,
            KbY = 28,
            KbZ = 29,
            KbISO = 100,
            KbNumpad0 = 98,
            KbNumpad1 = 89,
            KbNumpad2 = 90,
            KbNumpad3 = 91,
            KbNumpad4 = 92,
            KbNumpad5 = 93,
            KbNumpad6 = 94,
            KbNumpad7 = 95,
            KbNumpad8 = 96,
            KbNumpad9 = 97,
            KbNumpadAdd = 87,
            KbNumpadSubtract = 86,
            KbNumpadMultiply = 85,
            KbNumpadDivide = 84,
            KbRangeEnd = 255,
            MsRangeBegin = 256,
            MsLeft = 256,
            MsMiddle = 257,
            MsRight = 258,
            MsWheelUp = 259,
            MsWheelDown = 260,
            MsOther0 = 261,
            MsOther1 = 262,
            MsOther2 = 263,
            MsOther3 = 264,
            MsOther4 = 265,
            MsOther5 = 266,
            MsOther6 = 267,
            MsOther7 = 268,
            MsRangeEnd = 272,
            GpRangeBegin = 273,
            GpLeft = 273,
            GpRight = 274,
            GpUp = 275,
            GpDown = 276,
            GpButton0 = 277,
            GpButton1 = 278,
            GpButton2 = 279,
            GpButton3 = 280,
            GpButton4 = 281,
            GpButton5 = 282,
            GpButton6 = 283,
            GpButton7 = 284,
            GpButton8 = 285,
            GpButton9 = 286,
            GpButton10 = 287,
            GpButton11 = 288,
            GpButton12 = 289,
            GpButton13 = 290,
            GpButton14 = 291,
            GpButton15 = 292,
            Gp0Left = 293,
            Gp0Right = 294,
            Gp0Up = 295,
            Gp0Down = 296,
            Gp0Button0 = 297,
            Gp0Button1 = 298,
            Gp0Button2 = 299,
            Gp0Button3 = 300,
            Gp0Button4 = 301,
            Gp0Button5 = 302,
            Gp0Button6 = 303,
            Gp0Button7 = 304,
            Gp0Button8 = 305,
            Gp0Button9 = 306,
            Gp0Button10 = 307,
            Gp0Button11 = 308,
            Gp0Button12 = 309,
            Gp0Button13 = 310,
            Gp0Button14 = 311,
            Gp0Button15 = 312,
            Gp1Left = 313,
            Gp1Right = 314,
            Gp1Up = 315,
            Gp1Down = 316,
            Gp1Button0 = 317,
            Gp1Button1 = 318,
            Gp1Button2 = 319,
            Gp1Button3 = 320,
            Gp1Button4 = 321,
            Gp1Button5 = 322,
            Gp1Button6 = 323,
            Gp1Button7 = 324,
            Gp1Button8 = 325,
            Gp1Button9 = 326,
            Gp1Button10 = 327,
            Gp1Button11 = 328,
            Gp1Button12 = 329,
            Gp1Button13 = 330,
            Gp1Button14 = 331,
            Gp1Button15 = 332,
            Gp2Left = 333,
            Gp2Right = 334,
            Gp2Up = 335,
            Gp2Down = 336,
            Gp2Button0 = 337,
            Gp2Button1 = 338,
            Gp2Button2 = 339,
            Gp2Button3 = 340,
            Gp2Button4 = 341,
            Gp2Button5 = 342,
            Gp2Button6 = 343,
            Gp2Button7 = 344,
            Gp2Button8 = 345,
            Gp2Button9 = 346,
            Gp2Button10 = 347,
            Gp2Button11 = 348,
            Gp2Button12 = 349,
            Gp2Button13 = 350,
            Gp2Button14 = 351,
            Gp2Button15 = 352,
            Gp3Left = 353,
            Gp3Right = 354,
            Gp3Up = 355,
            Gp3Down = 356,
            Gp3Button0 = 357,
            Gp3Button1 = 358,
            Gp3Button2 = 359,
            Gp3Button3 = 360,
            Gp3Button4 = 361,
            Gp3Button5 = 362,
            Gp3Button6 = 363,
            Gp3Button7 = 364,
            Gp3Button8 = 365,
            Gp3Button9 = 366,
            Gp3Button10 = 367,
            Gp3Button11 = 368,
            Gp3Button12 = 369,
            Gp3Button13 = 370,
            Gp3Button14 = 371,
            Gp3Button15 = 372,
            GpRangeEnd = 372,
            NumButtons = 373,
            NumGamepads = 4,
            NoButton = -1,
            KbNum = 256,
            MsNum = 17,
            GpNum = 100,
            GpNumPerGamepad = 20
        }
    }

    namespace Gosu
    {
        // <summary>
        // <para>Very lightweight class that identifies a button (keyboard, mouse or other device).</para>
        // </summary>
        public unsafe partial class Button : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                public uint id_;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Button@Gosu@@QAE@I@Z")]
                internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Button@Gosu@@QAE@XZ")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Button@Gosu@@QAE@W4ButtonName@1@@Z")]
                internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, Gosu.ButtonName name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Button@Gosu@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??8Gosu@@YA_NVButton@0@0@Z")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(Gosu.Button.__Internal lhs, Gosu.Button.__Internal rhs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??9Gosu@@YA_NVButton@0@0@Z")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(Gosu.Button.__Internal lhs, Gosu.Button.__Internal rhs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??MGosu@@YA_NVButton@0@0@Z")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorLess_0(Gosu.Button.__Internal lhs, Gosu.Button.__Internal rhs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?id@Button@Gosu@@QBEIXZ")]
                internal static extern uint Id_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Button> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Button>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static Button __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new Button(native.ToPointer(), skipVTables);
            }

            public static Button __CreateInstance(Button.__Internal native, bool skipVTables = false)
            {
                return new Button(native, skipVTables);
            }

            private static void* __CopyValue(Button.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(4);
                *(Button.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Button(Button.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Button(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            // <summary>
            // <para>For internal use.</para>
            // </summary>
            public Button(uint id)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor_0((__Instance + __PointerAdjustment), id);
            }

            // <summary>
            // <para>Default constructor; == noButton.</para>
            // </summary>
            public Button()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor_1((__Instance + __PointerAdjustment));
            }

            // <summary>
            // <para>Conversion from ButtonName constants.</para>
            // </summary>
            public Button(Gosu.ButtonName name)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = name;
                __Internal.ctor_2((__Instance + __PointerAdjustment), __arg0);
            }

            public Button(Gosu.Button _0)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((Button.__Internal*) __Instance) = *((Button.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                Gosu.Button __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static bool operator >(Gosu.Button lhs, Gosu.Button rhs)
            {
                return !(lhs < rhs);
            }

            public static explicit operator Gosu.Button(uint id)
            {
                return new Gosu.Button(id);
            }

            public static implicit operator Gosu.Button(Gosu.ButtonName name)
            {
                return new Gosu.Button(name);
            }

            // <summary>
            // <para>Tests whether two Buttons identify the same physical button.</para>
            // </summary>
            public static bool operator ==(Gosu.Button lhs, Gosu.Button rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = ReferenceEquals(lhs, null) ? new Gosu.Button.__Internal() : *(Gosu.Button.__Internal*) lhs.__Instance;
                var __arg1 = ReferenceEquals(rhs, null) ? new Gosu.Button.__Internal() : *(Gosu.Button.__Internal*) rhs.__Instance;
                var __ret = __Internal.OperatorEqualEqual_0(__arg0, __arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as Button;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(Gosu.Button lhs, Gosu.Button rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = ReferenceEquals(lhs, null) ? new Gosu.Button.__Internal() : *(Gosu.Button.__Internal*) lhs.__Instance;
                var __arg1 = ReferenceEquals(rhs, null) ? new Gosu.Button.__Internal() : *(Gosu.Button.__Internal*) rhs.__Instance;
                var __ret = __Internal.OperatorExclaimEqual_0(__arg0, __arg1);
                return __ret;
            }

            public static bool operator <(Gosu.Button lhs, Gosu.Button rhs)
            {
                var __arg0 = ReferenceEquals(lhs, null) ? new Gosu.Button.__Internal() : *(Gosu.Button.__Internal*) lhs.__Instance;
                var __arg1 = ReferenceEquals(rhs, null) ? new Gosu.Button.__Internal() : *(Gosu.Button.__Internal*) rhs.__Instance;
                var __ret = __Internal.OperatorLess_0(__arg0, __arg1);
                return __ret;
            }

            // <summary>
            // <para>For internal use.</para>
            // </summary>
            public uint Id
            {
                get
                {
                    var __ret = __Internal.Id_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        // <summary>
        // <para>Struct that saves information about a touch on the surface of a multi-</para>
        // <para>touch device.</para>
        // <para>Available even on non-iPhone platforms to make it easier to compile the</para>
        // <para>same source for multiple platforms.</para>
        // </summary>
        public unsafe partial class Touch : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr id;

                [FieldOffset(4)]
                public float x;

                [FieldOffset(8)]
                public float y;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Touch@Gosu@@QAE@ABU01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Touch> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Touch>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static Touch __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new Touch(native.ToPointer(), skipVTables);
            }

            public static Touch __CreateInstance(Touch.__Internal native, bool skipVTables = false)
            {
                return new Touch(native, skipVTables);
            }

            private static void* __CopyValue(Touch.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(12);
                *(Touch.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Touch(Touch.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Touch(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public Touch()
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Touch(Gosu.Touch _0)
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((Touch.__Internal*) __Instance) = *((Touch.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                Gosu.Touch __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public global::System.IntPtr id
            {
                get
                {
                    return ((__Internal*) __Instance)->id;
                }

                set
                {
                    ((__Internal*) __Instance)->id = (global::System.IntPtr) value;
                }
            }

            public float x
            {
                get
                {
                    return ((__Internal*) __Instance)->x;
                }

                set
                {
                    ((__Internal*) __Instance)->x = value;
                }
            }

            public float y
            {
                get
                {
                    return ((__Internal*) __Instance)->y;
                }

                set
                {
                    ((__Internal*) __Instance)->y = value;
                }
            }
        }

        // <summary>
        // <para>Manages initialization and shutdown of the input system. Only one Input</para>
        // <para>instance can exist per application.</para>
        // </summary>
        public unsafe partial class Input : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 248)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Std.UniquePtr.__Internal pimpl;

                [FieldOffset(8)]
                internal global::Std.Function.__Internal onButtonDown;

                [FieldOffset(48)]
                internal global::Std.Function.__Internal onButtonUp;

                [FieldOffset(88)]
                internal global::Std.Function.__Internal onTouchBegan;

                [FieldOffset(128)]
                internal global::Std.Function.__Internal onTouchMoved;

                [FieldOffset(168)]
                internal global::Std.Function.__Internal onTouchEnded;

                [FieldOffset(208)]
                internal global::Std.Function.__Internal onTouchCancelled;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Input@Gosu@@QAE@PAX@Z")]
                internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, global::System.IntPtr window);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??1Input@Gosu@@QAE@XZ")]
                internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?feedSDLEvent@Input@Gosu@@QAE_NPAX@Z")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool FeedSDLEvent_0(global::System.IntPtr instance, global::System.IntPtr @event);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?idToChar@Input@Gosu@@SA_WVButton@2@@Z")]
                internal static extern char IdToChar_0(Gosu.Button.__Internal btn);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?charToId@Input@Gosu@@SA?AVButton@2@_W@Z")]
                internal static extern void CharToId_0(global::System.IntPtr @return, char ch);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?down@Input@Gosu@@SA_NVButton@2@@Z")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool Down_0(Gosu.Button.__Internal btn);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setMousePosition@Input@Gosu@@QAEXNN@Z")]
                internal static extern void SetMousePosition_0(global::System.IntPtr instance, double x, double y);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setMouseFactors@Input@Gosu@@QAEXNNNN@Z")]
                internal static extern void SetMouseFactors_0(global::System.IntPtr instance, double factorX, double factorY, double offsetX, double offsetY);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?update@Input@Gosu@@QAEXXZ")]
                internal static extern void Update_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?textInput@Input@Gosu@@QBEPAVTextInput@2@XZ")]
                internal static extern global::System.IntPtr TextInput_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?setTextInput@Input@Gosu@@QAEXPAVTextInput@2@@Z")]
                internal static extern void SetTextInput_0(global::System.IntPtr instance, global::System.IntPtr input);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?mouseX@Input@Gosu@@QBENXZ")]
                internal static extern double MouseX_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?mouseY@Input@Gosu@@QBENXZ")]
                internal static extern double MouseY_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?accelerometerX@Input@Gosu@@QBENXZ")]
                internal static extern double AccelerometerX_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?accelerometerY@Input@Gosu@@QBENXZ")]
                internal static extern double AccelerometerY_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?accelerometerZ@Input@Gosu@@QBENXZ")]
                internal static extern double AccelerometerZ_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Input> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Input>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            public static Input __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new Input(native.ToPointer(), skipVTables);
            }

            public static Input __CreateInstance(Input.__Internal native, bool skipVTables = false)
            {
                return new Input(native, skipVTables);
            }

            private static void* __CopyValue(Input.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(248);
                *(Input.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Input(Input.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Input(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public Input(global::System.IntPtr window)
            {
                __Instance = Marshal.AllocHGlobal(248);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = window;
                __Internal.ctor_2((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                Gosu.Input __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool FeedSDLEvent(global::System.IntPtr @event)
            {
                var __arg0 = @event;
                var __ret = __Internal.FeedSDLEvent_0((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            // <summary>
            // <para>Immediately moves the mouse as far towards the desired position</para>
            // <para>as possible. x and y are relative to the window, just as in mouseX()</para>
            // <para>and mouseY(), so (0, 0) is the top left corner of the window..</para>
            // </summary>
            public void SetMousePosition(double x, double y)
            {
                __Internal.SetMousePosition_0((__Instance + __PointerAdjustment), x, y);
            }

            public void SetMouseFactors(double factorX, double factorY, double offsetX = 0, double offsetY = 0)
            {
                __Internal.SetMouseFactors_0((__Instance + __PointerAdjustment), factorX, factorY, offsetX, offsetY);
            }

            // <summary>
            // <para>Collects new information about which buttons are pressed, where the</para>
            // <para>mouse is and calls onButtonUp/onButtonDown, if assigned.</para>
            // </summary>
            public void Update()
            {
                __Internal.Update_0((__Instance + __PointerAdjustment));
            }

            public static implicit operator Gosu.Input(global::System.IntPtr window)
            {
                return new Gosu.Input(window);
            }

            // <summary>
            // <para>Returns the character a button usually produces, or 0.</para>
            // </summary>
            public static char IdToChar(Gosu.Button btn)
            {
                var __arg0 = ReferenceEquals(btn, null) ? new Gosu.Button.__Internal() : *(Gosu.Button.__Internal*) btn.__Instance;
                var __ret = __Internal.IdToChar_0(__arg0);
                return __ret;
            }

            // <summary>
            // <para>Returns the button that has to be pressed to produce the</para>
            // <para>given character, or noButton.</para>
            // </summary>
            public static Gosu.Button CharToId(char ch)
            {
                var __ret = new Gosu.Button.__Internal();
                __Internal.CharToId_0(new IntPtr(&__ret), ch);
                return Gosu.Button.__CreateInstance(__ret);
            }

            // <summary>
            // <para>Returns true if a button is currently pressed.</para>
            // <para>Updated every tick.</para>
            // </summary>
            public static bool Down(Gosu.Button btn)
            {
                var __arg0 = ReferenceEquals(btn, null) ? new Gosu.Button.__Internal() : *(Gosu.Button.__Internal*) btn.__Instance;
                var __ret = __Internal.Down_0(__arg0);
                return __ret;
            }

            // <summary>
            // <para>Returns the currently active TextInput instance, or 0.</para>
            // </summary>
            // <remarks>
            // <para>Sets the currently active TextInput, or clears it (input = 0).</para>
            // </remarks>
            public Gosu.TextInput TextInput
            {
                get
                {
                    var __ret = __Internal.TextInput_0((__Instance + __PointerAdjustment));
                    Gosu.TextInput __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (Gosu.TextInput.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (Gosu.TextInput) Gosu.TextInput.NativeToManagedMap[__ret];
                    else __result0 = Gosu.TextInput.__CreateInstance(__ret);
                    return __result0;
                }

                set
                {
                    var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    __Internal.SetTextInput_0((__Instance + __PointerAdjustment), __arg0);
                }
            }

            // <summary>
            // <para>Returns the horizontal position of the mouse relative to the top</para>
            // <para>left corner of the window given to Input's constructor.</para>
            // </summary>
            public double MouseX
            {
                get
                {
                    var __ret = __Internal.MouseX_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            // <summary>
            // <para>See mouseX.</para>
            // </summary>
            public double MouseY
            {
                get
                {
                    var __ret = __Internal.MouseY_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            // <summary>
            // <para>Accelerometer positions in all three dimensions (smoothened).</para>
            // <para>Note: Not really deprecated - but temporarily defunct.</para>
            // </summary>
            public double AccelerometerX
            {
                get
                {
                    var __ret = __Internal.AccelerometerX_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public double AccelerometerY
            {
                get
                {
                    var __ret = __Internal.AccelerometerY_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public double AccelerometerZ
            {
                get
                {
                    var __ret = __Internal.AccelerometerZ_0((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }
    }

    namespace Gosu
    {
        public unsafe partial class Timing
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?sleep@Gosu@@YAXI@Z")]
                internal static extern void Sleep_0(uint milliseconds);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Gosu.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?milliseconds@Gosu@@YAKXZ")]
                internal static extern uint Milliseconds_0();
            }

            // <summary>
            // <para>Freezes the current thread for at least the specified time.</para>
            // </summary>
            public static void Sleep(uint milliseconds)
            {
                __Internal.Sleep_0(milliseconds);
            }

            // <summary>
            // <para>Incrementing, possibly wrapping millisecond timer.</para>
            // </summary>
            public static uint Milliseconds()
            {
                var __ret = __Internal.Milliseconds_0();
                return __ret;
            }
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        public unsafe delegate void Action_IntPtr_int(global::System.IntPtr instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        public unsafe delegate global::System.IntPtr Func_string_IntPtr_string(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        public unsafe delegate void Action_IntPtr(global::System.IntPtr instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        public unsafe delegate bool Func_bool_IntPtr(global::System.IntPtr instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        public unsafe delegate void Action_IntPtr_Gosu_Button___Internal(global::System.IntPtr instance, Gosu.Button.__Internal arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        public unsafe delegate void Action_IntPtr_Gosu_Touch___Internal(global::System.IntPtr instance, Gosu.Touch.__Internal arg1);
    }
}
